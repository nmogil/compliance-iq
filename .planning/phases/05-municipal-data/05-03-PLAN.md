---
phase: 05-municipal-data
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/workers/src/municipal/storage.ts
  - apps/workers/src/municipal/index.ts
autonomous: true

must_haves:
  truths:
    - "Municipal ordinances stored in R2 with city-based hierarchy"
    - "Checkpoints enable pipeline resumption after failure"
    - "Raw markdown cached in R2 to avoid redundant Firecrawl calls"
  artifacts:
    - path: "apps/workers/src/municipal/storage.ts"
      provides: "R2 storage functions for ordinances, markdown cache, and checkpoints"
      exports: ["storeMunicipalOrdinance", "storeMunicipalMarkdown", "saveMunicipalCheckpoint", "loadMunicipalCheckpoint"]
      min_lines: 120
  key_links:
    - from: "apps/workers/src/municipal/storage.ts"
      to: "R2_BUCKET"
      via: "Cloudflare Workers binding"
      pattern: "env\\.R2_BUCKET"
---

<objective>
Create R2 storage module for municipal ordinances with markdown caching and checkpoint management.

Purpose: Enable persistent storage of scraped data and pipeline state for fault tolerance and cost optimization (cache Firecrawl markdown to avoid redundant API calls).
Output: Storage functions for ordinances, raw markdown, and checkpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-municipal-data/05-CONTEXT.md
@.planning/phases/05-municipal-data/05-RESEARCH.md
@apps/workers/src/counties/storage.ts
@apps/workers/src/federal/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create municipal storage module</name>
  <files>apps/workers/src/municipal/storage.ts</files>
  <action>
Create R2 storage following county/storage.ts patterns:

```typescript
import type { MunicipalOrdinance, MunicipalCheckpoint, MunicipalCityConfig } from './types';

/**
 * Environment bindings for Cloudflare Workers
 */
export interface Env {
  R2_BUCKET: R2Bucket;
}

// ============================================================================
// R2 Key Patterns
// ============================================================================

/**
 * R2 folder structure:
 * - municipal/{cityId}/chapter-{chapter}/{section}.json  - Parsed ordinances
 * - municipal/{cityId}/raw/page.md                       - Raw markdown cache
 * - municipal/checkpoints/municipal.json                 - Pipeline checkpoint
 */

function getOrdinanceKey(cityId: string, chapter: string, section: string): string {
  return `municipal/${cityId}/chapter-${chapter}/${section}.json`;
}

function getMarkdownCacheKey(cityId: string): string {
  return `municipal/${cityId}/raw/page.md`;
}

function getCheckpointKey(): string {
  return 'municipal/checkpoints/municipal.json';
}

// ============================================================================
// Ordinance Storage
// ============================================================================

/**
 * Store a parsed municipal ordinance in R2
 *
 * @param env Cloudflare Workers environment
 * @param ordinance Parsed ordinance to store
 */
export async function storeMunicipalOrdinance(
  env: Env,
  ordinance: MunicipalOrdinance
): Promise<void> {
  const key = getOrdinanceKey(ordinance.cityId, ordinance.chapter, ordinance.section);

  await env.R2_BUCKET.put(
    key,
    JSON.stringify(ordinance, null, 2),
    {
      httpMetadata: { contentType: 'application/json' },
      customMetadata: {
        cityId: ordinance.cityId,
        chapter: ordinance.chapter,
        section: ordinance.section,
        scrapedAt: ordinance.scrapedAt.toISOString(),
      },
    }
  );
}

/**
 * Retrieve a stored municipal ordinance from R2
 *
 * @returns Parsed ordinance or null if not found
 */
export async function getMunicipalOrdinance(
  env: Env,
  cityId: string,
  chapter: string,
  section: string
): Promise<MunicipalOrdinance | null> {
  const key = getOrdinanceKey(cityId, chapter, section);
  const object = await env.R2_BUCKET.get(key);

  if (!object) return null;

  const text = await object.text();
  const data = JSON.parse(text);

  // Restore Date object
  return {
    ...data,
    scrapedAt: new Date(data.scrapedAt),
  };
}

/**
 * List all ordinances for a city
 *
 * @returns Array of section identifiers
 */
export async function listMunicipalOrdinances(
  env: Env,
  cityId: string
): Promise<string[]> {
  const prefix = `municipal/${cityId}/chapter-`;
  const listed = await env.R2_BUCKET.list({ prefix });

  return listed.objects.map(obj => {
    // Extract section from key: municipal/houston/chapter-1/1-2.json -> 1-2
    const match = obj.key.match(/chapter-[\d]+\/([\d.-]+)\.json$/);
    return match ? match[1] : obj.key;
  });
}

/**
 * Store multiple ordinances for a city
 *
 * @returns Number of ordinances stored
 */
export async function storeMunicipalOrdinances(
  env: Env,
  ordinances: MunicipalOrdinance[]
): Promise<number> {
  let stored = 0;
  for (const ordinance of ordinances) {
    await storeMunicipalOrdinance(env, ordinance);
    stored++;
  }
  return stored;
}

// ============================================================================
// Markdown Cache (for Firecrawl cost optimization)
// ============================================================================

/**
 * Store raw markdown from Firecrawl to avoid redundant API calls
 *
 * Per 05-RESEARCH.md pitfall #1: Cache raw markdown in R2 to minimize Firecrawl credits.
 */
export async function storeMunicipalMarkdown(
  env: Env,
  cityId: string,
  markdown: string,
  metadata: { title: string; sourceUrl: string; scrapedAt: Date }
): Promise<void> {
  const key = getMarkdownCacheKey(cityId);

  await env.R2_BUCKET.put(
    key,
    markdown,
    {
      httpMetadata: { contentType: 'text/markdown' },
      customMetadata: {
        cityId,
        title: metadata.title,
        sourceUrl: metadata.sourceUrl,
        scrapedAt: metadata.scrapedAt.toISOString(),
      },
    }
  );
}

/**
 * Retrieve cached markdown for a city
 *
 * @returns Cached markdown or null if not found/expired
 */
export async function getMunicipalMarkdown(
  env: Env,
  cityId: string,
  maxAgeMs?: number
): Promise<{ markdown: string; scrapedAt: Date } | null> {
  const key = getMarkdownCacheKey(cityId);
  const object = await env.R2_BUCKET.get(key);

  if (!object) return null;

  // Check age if maxAgeMs specified
  if (maxAgeMs && object.customMetadata?.scrapedAt) {
    const scrapedAt = new Date(object.customMetadata.scrapedAt);
    const age = Date.now() - scrapedAt.getTime();
    if (age > maxAgeMs) {
      console.log(`[Municipal] Markdown cache expired for ${cityId} (${Math.round(age / 86400000)} days old)`);
      return null;
    }
  }

  const markdown = await object.text();
  const scrapedAt = object.customMetadata?.scrapedAt
    ? new Date(object.customMetadata.scrapedAt)
    : new Date();

  return { markdown, scrapedAt };
}

// ============================================================================
// Checkpoint Management
// ============================================================================

/**
 * Save pipeline checkpoint for resumption
 *
 * Single checkpoint for all municipal processing (unlike per-source county pattern).
 */
export async function saveMunicipalCheckpoint(
  env: Env,
  checkpoint: MunicipalCheckpoint
): Promise<void> {
  const key = getCheckpointKey();

  await env.R2_BUCKET.put(
    key,
    JSON.stringify(checkpoint, null, 2),
    {
      httpMetadata: { contentType: 'application/json' },
      customMetadata: {
        lastUpdated: checkpoint.lastUpdated,
        processedCount: checkpoint.processedCities.length.toString(),
      },
    }
  );
}

/**
 * Load pipeline checkpoint
 *
 * @returns Checkpoint or null if fresh start
 */
export async function loadMunicipalCheckpoint(
  env: Env
): Promise<MunicipalCheckpoint | null> {
  const key = getCheckpointKey();
  const object = await env.R2_BUCKET.get(key);

  if (!object) return null;

  const text = await object.text();
  return JSON.parse(text);
}

/**
 * Clear checkpoint for fresh pipeline run
 */
export async function clearMunicipalCheckpoint(env: Env): Promise<void> {
  const key = getCheckpointKey();
  await env.R2_BUCKET.delete(key);
}

// ============================================================================
// Storage Statistics
// ============================================================================

/**
 * Get storage statistics for monitoring
 */
export async function getMunicipalStorageStats(
  env: Env
): Promise<{
  totalOrdinances: number;
  citiesWithData: string[];
  markdownCacheCount: number;
  checkpointExists: boolean;
}> {
  // Count ordinances
  const ordinanceList = await env.R2_BUCKET.list({ prefix: 'municipal/' });
  const ordinances = ordinanceList.objects.filter(o => o.key.endsWith('.json') && !o.key.includes('checkpoints'));

  // Extract unique city IDs
  const cities = new Set<string>();
  for (const obj of ordinances) {
    const match = obj.key.match(/^municipal\/([^/]+)\//);
    if (match && match[1] !== 'checkpoints') {
      cities.add(match[1]);
    }
  }

  // Count markdown caches
  const markdownList = await env.R2_BUCKET.list({ prefix: 'municipal/' });
  const markdownCaches = markdownList.objects.filter(o => o.key.endsWith('/raw/page.md'));

  // Check checkpoint
  const checkpoint = await env.R2_BUCKET.get(getCheckpointKey());

  return {
    totalOrdinances: ordinances.length,
    citiesWithData: Array.from(cities),
    markdownCacheCount: markdownCaches.length,
    checkpointExists: checkpoint !== null,
  };
}
```
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - no errors on storage.ts</verify>
  <done>R2 storage module with 10 functions for ordinances, markdown cache, checkpoints, and stats</done>
</task>

<task type="auto">
  <name>Task 2: Update module exports</name>
  <files>apps/workers/src/municipal/index.ts</files>
  <action>
Update municipal/index.ts to export storage module:

```typescript
export * from './types';
export * from './cities';
export * from './storage';
```

Note: scraper and parser exports will be added in 05-02-PLAN after those modules are created.
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - index.ts compiles</verify>
  <done>Storage functions exported from municipal/index.ts</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `pnpm --filter @compliance-iq/workers exec tsc --noEmit`
2. Storage functions follow county/storage.ts patterns
3. R2 key structure: municipal/{cityId}/chapter-{chapter}/{section}.json
4. Markdown cache at municipal/{cityId}/raw/page.md
5. Checkpoint at municipal/checkpoints/municipal.json
6. All storage functions exported from municipal/index.ts
</verification>

<success_criteria>
- 10 storage functions implemented:
  - storeMunicipalOrdinance, getMunicipalOrdinance, listMunicipalOrdinances, storeMunicipalOrdinances
  - storeMunicipalMarkdown, getMunicipalMarkdown (for Firecrawl cache)
  - saveMunicipalCheckpoint, loadMunicipalCheckpoint, clearMunicipalCheckpoint
  - getMunicipalStorageStats
- R2 folder structure documented and consistent
- Markdown caching supports maxAgeMs parameter for cache expiration
- All exports available from municipal/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/05-municipal-data/05-03-SUMMARY.md`
</output>
