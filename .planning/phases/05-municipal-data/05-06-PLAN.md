---
phase: 05-municipal-data
plan: 06
type: execute
wave: 4
depends_on: ["05-05"]
files_modified:
  - apps/workers/src/index.ts
  - apps/convex/convex/schema.ts
  - apps/convex/convex/jurisdictions.ts
  - apps/workers/src/municipal/coverage.ts
  - apps/workers/src/municipal/index.ts
  - scripts/test-municipal-query.ts
autonomous: true

must_haves:
  truths:
    - "HTTP endpoints trigger municipal pipeline processing"
    - "Convex tracks all 20 cities with coverage status"
    - "Test queries filtered by city return relevant municipal codes"
  artifacts:
    - path: "apps/workers/src/index.ts"
      provides: "HTTP endpoints for municipal pipeline"
      contains: "/pipeline/municipal"
    - path: "apps/convex/convex/jurisdictions.ts"
      provides: "Municipal jurisdiction tracking functions"
      exports: ["listTexasCities", "updateCityStatus"]
    - path: "apps/workers/src/municipal/coverage.ts"
      provides: "Coverage report generator"
      exports: ["generateMunicipalCoverageReport"]
  key_links:
    - from: "apps/workers/src/index.ts"
      to: "apps/workers/src/municipal/pipeline.ts"
      via: "imports processAllCities"
      pattern: "import.*processAllCities"
---

<objective>
Add HTTP endpoints for municipal pipeline triggering and Convex coverage tracking.

Purpose: Enable manual pipeline execution and track municipal data coverage across 20 Texas cities.
Output: HTTP endpoints, Convex functions, coverage report generator, and query test script.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-municipal-data/05-CONTEXT.md
@.planning/phases/05-municipal-data/05-05-SUMMARY.md
@apps/workers/src/index.ts
@apps/convex/convex/schema.ts
@apps/convex/convex/jurisdictions.ts
@apps/workers/src/counties/coverage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add municipal HTTP endpoints</name>
  <files>apps/workers/src/index.ts</files>
  <action>
Add HTTP endpoints for municipal pipeline following county pattern:

```typescript
// Add imports at top of file
import {
  processAllCities,
  processSingleCity,
  getMunicipalPipelineStatus,
  resetMunicipalPipeline,
  getEnabledCities,
  getSkippedCities,
  type MunicipalBatchPipelineResult,
  type MunicipalPipelineResult,
} from './municipal';

// Add routes in the main router (after county routes)

/**
 * POST /pipeline/municipal
 * Process all 20 enabled Texas cities
 *
 * Query params:
 * - resume=true: Resume from checkpoint
 * - skipCache=true: Force fresh Firecrawl scraping
 * - cities=houston,dallas: Filter to specific cities
 */
// Route: POST /pipeline/municipal
if (request.method === 'POST' && url.pathname === '/pipeline/municipal') {
  const resume = url.searchParams.get('resume') === 'true';
  const skipCache = url.searchParams.get('skipCache') === 'true';
  const citiesParam = url.searchParams.get('cities');
  const cityFilter = citiesParam ? citiesParam.split(',') : undefined;

  const result = await processAllCities(env, {
    resumeFromCheckpoint: resume,
    skipCache,
    cityFilter,
  });

  // Return 207 Multi-Status if some cities failed
  const status = result.failed.length > 0 && result.successful.length > 0 ? 207 : 200;

  return new Response(JSON.stringify(result), {
    status,
    headers: { 'Content-Type': 'application/json' },
  });
}

/**
 * POST /pipeline/municipal/:city
 * Process single city by name or ID
 *
 * Query params:
 * - skipCache=true: Force fresh Firecrawl scraping
 */
// Route: POST /pipeline/municipal/:city
const municipalCityMatch = url.pathname.match(/^\/pipeline\/municipal\/([^/]+)$/);
if (request.method === 'POST' && municipalCityMatch) {
  const cityIdOrName = decodeURIComponent(municipalCityMatch[1]);
  const skipCache = url.searchParams.get('skipCache') === 'true';

  try {
    const result = await processSingleCity(env, cityIdOrName, { skipCache });
    return new Response(JSON.stringify(result), {
      status: 200,
      headers: { 'Content-Type': 'application/json' },
    });
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return new Response(JSON.stringify({ error: message }), {
      status: 404,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}

/**
 * GET /pipeline/municipal/status
 * Get pipeline status and storage statistics
 */
// Route: GET /pipeline/municipal/status
if (request.method === 'GET' && url.pathname === '/pipeline/municipal/status') {
  const status = await getMunicipalPipelineStatus(env);
  const enabled = getEnabledCities();
  const skipped = getSkippedCities();

  return new Response(JSON.stringify({
    ...status,
    cities: {
      enabled: enabled.map(c => ({ name: c.name, cityId: c.cityId, platform: c.platform })),
      skipped: skipped.map(c => ({ name: c.name, cityId: c.cityId, reason: c.skipReason })),
    },
  }), {
    headers: { 'Content-Type': 'application/json' },
  });
}

/**
 * POST /pipeline/municipal/reset
 * Clear checkpoint for fresh pipeline run
 */
// Route: POST /pipeline/municipal/reset
if (request.method === 'POST' && url.pathname === '/pipeline/municipal/reset') {
  await resetMunicipalPipeline(env);
  return new Response(JSON.stringify({ success: true, message: 'Municipal pipeline checkpoint cleared' }), {
    headers: { 'Content-Type': 'application/json' },
  });
}
```

HTTP endpoints to add:
| Method | Path | Description |
|--------|------|-------------|
| POST | /pipeline/municipal | Process all 20 enabled Texas cities |
| POST | /pipeline/municipal/:city | Process single city by name/ID |
| GET | /pipeline/municipal/status | Get pipeline status and storage stats |
| POST | /pipeline/municipal/reset | Clear checkpoint for fresh run |
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - no errors in index.ts</verify>
  <done>4 HTTP endpoints added for municipal pipeline</done>
</task>

<task type="auto">
  <name>Task 2: Update Convex schema and functions</name>
  <files>apps/convex/convex/schema.ts, apps/convex/convex/jurisdictions.ts</files>
  <action>
Update Convex to track municipal jurisdictions (extending county pattern):

**schema.ts updates:**
Add municipal fields to jurisdictions table if not already flexible enough, or document that existing schema handles it:

```typescript
// The jurisdictions table likely already supports municipal via "type" field
// Verify and add index if needed:
.index('by_city_id', ['cityId'])  // For municipal lookups
```

**jurisdictions.ts updates:**
Add municipal-specific functions:

```typescript
import { query, mutation } from './_generated/server';
import { v } from 'convex/values';

/**
 * List all 20 target Texas cities with status
 */
export const listTexasCities = query({
  args: {},
  handler: async (ctx) => {
    // List all municipal jurisdictions
    const cities = await ctx.db
      .query('jurisdictions')
      .filter(q => q.eq(q.field('type'), 'municipal'))
      .filter(q => q.eq(q.field('state'), 'TX'))
      .collect();

    return cities;
  },
});

/**
 * Update city status after pipeline processing
 */
export const updateCityStatus = mutation({
  args: {
    cityId: v.string(),
    status: v.union(v.literal('pending'), v.literal('active'), v.literal('error')),
    vectorCount: v.optional(v.number()),
    lastScrapedAt: v.optional(v.string()),
    error: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Find existing city record
    const existing = await ctx.db
      .query('jurisdictions')
      .filter(q => q.eq(q.field('cityId'), args.cityId))
      .first();

    if (existing) {
      await ctx.db.patch(existing._id, {
        status: args.status,
        vectorCount: args.vectorCount,
        lastScrapedAt: args.lastScrapedAt,
        error: args.error,
      });
    } else {
      // Create new record
      await ctx.db.insert('jurisdictions', {
        type: 'municipal',
        state: 'TX',
        cityId: args.cityId,
        status: args.status,
        vectorCount: args.vectorCount ?? 0,
        lastScrapedAt: args.lastScrapedAt,
        error: args.error,
      });
    }
  },
});

/**
 * Get city by city ID
 */
export const getCityByCityId = query({
  args: { cityId: v.string() },
  handler: async (ctx, args) => {
    return await ctx.db
      .query('jurisdictions')
      .filter(q => q.eq(q.field('cityId'), args.cityId))
      .first();
  },
});

/**
 * Get aggregate coverage statistics for Texas cities
 */
export const getTexasCityCoverage = query({
  args: {},
  handler: async (ctx) => {
    const cities = await ctx.db
      .query('jurisdictions')
      .filter(q => q.eq(q.field('type'), 'municipal'))
      .filter(q => q.eq(q.field('state'), 'TX'))
      .collect();

    const active = cities.filter(c => c.status === 'active').length;
    const pending = cities.filter(c => c.status === 'pending').length;
    const error = cities.filter(c => c.status === 'error').length;
    const totalVectors = cities.reduce((sum, c) => sum + (c.vectorCount ?? 0), 0);

    return {
      total: cities.length,
      active,
      pending,
      error,
      totalVectors,
      coverage: cities.length > 0 ? ((active / 20) * 100).toFixed(1) + '%' : '0%',
    };
  },
});
```

If schema needs updating to support cityId field, add it. Otherwise, verify existing schema is flexible enough.
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/convex exec tsc --noEmit` or `pnpm convex typecheck`</verify>
  <done>Convex functions for municipal jurisdiction tracking</done>
</task>

<task type="auto">
  <name>Task 3: Create coverage report generator and test script</name>
  <files>apps/workers/src/municipal/coverage.ts, apps/workers/src/municipal/index.ts, scripts/test-municipal-query.ts</files>
  <action>
Create coverage report generator (following county pattern):

**coverage.ts:**
```typescript
import { getEnabledCities, getSkippedCities, type MunicipalCityConfig } from './cities';
import { getMunicipalStorageStats, type Env } from './storage';

/**
 * Coverage report for municipal data
 */
export interface MunicipalCoverageReport {
  generated: string;
  summary: {
    totalCities: number;
    enabledCities: number;
    skippedCities: number;
    citiesWithData: number;
    totalOrdinances: number;
    platforms: {
      municode: number;
      amlegal: number;
    };
  };
  cities: Array<{
    name: string;
    cityId: string;
    platform: string;
    enabled: boolean;
    hasData: boolean;
    skipReason?: string;
  }>;
}

/**
 * Generate coverage report for municipal data
 */
export async function generateMunicipalCoverageReport(
  env: Env
): Promise<MunicipalCoverageReport> {
  const enabled = getEnabledCities();
  const skipped = getSkippedCities();
  const storage = await getMunicipalStorageStats(env);

  // Count platforms
  const municodeCount = enabled.filter(c => c.platform === 'municode').length;
  const amlegalCount = enabled.filter(c => c.platform === 'amlegal').length;

  // Build city details
  const cities = [
    ...enabled.map(c => ({
      name: c.name,
      cityId: c.cityId,
      platform: c.platform,
      enabled: true,
      hasData: storage.citiesWithData.includes(c.cityId),
    })),
    ...skipped.map(c => ({
      name: c.name,
      cityId: c.cityId,
      platform: c.platform,
      enabled: false,
      hasData: false,
      skipReason: c.skipReason,
    })),
  ];

  return {
    generated: new Date().toISOString(),
    summary: {
      totalCities: 20,
      enabledCities: enabled.length,
      skippedCities: skipped.length,
      citiesWithData: storage.citiesWithData.length,
      totalOrdinances: storage.totalOrdinances,
      platforms: {
        municode: municodeCount,
        amlegal: amlegalCount,
      },
    },
    cities,
  };
}

/**
 * Generate markdown coverage report
 */
export function formatCoverageReportMarkdown(report: MunicipalCoverageReport): string {
  let md = `# Municipal Data Coverage Report\n\n`;
  md += `Generated: ${report.generated}\n\n`;

  md += `## Summary\n\n`;
  md += `| Metric | Value |\n`;
  md += `|--------|-------|\n`;
  md += `| Total Cities | ${report.summary.totalCities} |\n`;
  md += `| Enabled | ${report.summary.enabledCities} |\n`;
  md += `| Skipped | ${report.summary.skippedCities} |\n`;
  md += `| With Data | ${report.summary.citiesWithData} |\n`;
  md += `| Total Ordinances | ${report.summary.totalOrdinances} |\n`;
  md += `| Municode Cities | ${report.summary.platforms.municode} |\n`;
  md += `| American Legal Cities | ${report.summary.platforms.amlegal} |\n\n`;

  md += `## City Details\n\n`;
  md += `| City | Platform | Enabled | Has Data |\n`;
  md += `|------|----------|---------|----------|\n`;

  for (const city of report.cities) {
    const enabled = city.enabled ? 'Yes' : `No (${city.skipReason ?? 'unknown'})`;
    const hasData = city.hasData ? 'Yes' : 'No';
    md += `| ${city.name} | ${city.platform} | ${enabled} | ${hasData} |\n`;
  }

  return md;
}
```

**Update municipal/index.ts:**
```typescript
export * from './coverage';
```

**Create scripts/test-municipal-query.ts:**
```typescript
/**
 * Test script for validating Pinecone municipal jurisdiction filtering
 *
 * Usage: pnpm tsx scripts/test-municipal-query.ts
 *
 * Tests that:
 * 1. Query filtered by TX-houston returns only Houston results
 * 2. Query filtered by jurisdiction includes municipal sourceType
 * 3. Results have expected metadata fields
 */

import { Pinecone } from '@pinecone-database/pinecone';
import OpenAI from 'openai';

const PINECONE_API_KEY = process.env.PINECONE_API_KEY!;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY!;
const INDEX_NAME = 'compliance-embeddings';

async function main() {
  console.log('Testing municipal jurisdiction filtering in Pinecone...\n');

  // Initialize clients
  const pinecone = new Pinecone({ apiKey: PINECONE_API_KEY });
  const openai = new OpenAI({ apiKey: OPENAI_API_KEY });
  const index = pinecone.Index(INDEX_NAME);

  // Test query
  const testQuery = 'food permit requirements for restaurant';

  // Generate embedding
  console.log(`Embedding query: "${testQuery}"`);
  const embeddingResponse = await openai.embeddings.create({
    model: 'text-embedding-3-large',
    input: testQuery,
    dimensions: 3072,
  });
  const queryVector = embeddingResponse.data[0].embedding;

  // Test 1: Query filtered by Houston
  console.log('\n--- Test 1: Houston-only filter ---');
  const houstonResults = await index.query({
    vector: queryVector,
    topK: 5,
    filter: {
      jurisdiction: 'TX-houston',
      sourceType: 'municipal',
    },
    includeMetadata: true,
  });

  console.log(`Results: ${houstonResults.matches.length}`);
  for (const match of houstonResults.matches) {
    console.log(`  - ${match.id}: ${match.metadata?.citation} (score: ${match.score?.toFixed(4)})`);
    if (match.metadata?.jurisdiction !== 'TX-houston') {
      console.error(`    ERROR: Wrong jurisdiction: ${match.metadata?.jurisdiction}`);
    }
  }

  // Test 2: Query all Texas municipal
  console.log('\n--- Test 2: All TX municipal filter ---');
  const allMunicipalResults = await index.query({
    vector: queryVector,
    topK: 10,
    filter: {
      sourceType: 'municipal',
    },
    includeMetadata: true,
  });

  console.log(`Results: ${allMunicipalResults.matches.length}`);
  const citiesSeen = new Set<string>();
  for (const match of allMunicipalResults.matches) {
    const city = match.metadata?.cityName as string;
    citiesSeen.add(city);
    console.log(`  - ${city}: ${match.metadata?.section} (score: ${match.score?.toFixed(4)})`);
  }
  console.log(`\nUnique cities in results: ${Array.from(citiesSeen).join(', ')}`);

  // Test 3: Verify metadata fields
  console.log('\n--- Test 3: Metadata field validation ---');
  if (allMunicipalResults.matches.length > 0) {
    const sample = allMunicipalResults.matches[0];
    const requiredFields = ['citation', 'sourceType', 'jurisdiction', 'sourceUrl', 'cityId', 'cityName', 'chapter', 'section'];
    const missing = requiredFields.filter(f => !sample.metadata?.[f]);

    if (missing.length > 0) {
      console.error(`Missing metadata fields: ${missing.join(', ')}`);
    } else {
      console.log('All required metadata fields present');
    }
  }

  console.log('\n--- Tests complete ---');
}

main().catch(console.error);
```
  </action>
  <verify>
Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - coverage.ts compiles
Verify scripts/test-municipal-query.ts has no syntax errors
  </verify>
  <done>Coverage report generator and Pinecone query test script created</done>
</task>

</tasks>

<verification>
1. TypeScript compiles for all modified files
2. HTTP endpoints accessible:
   - POST /pipeline/municipal
   - POST /pipeline/municipal/:city
   - GET /pipeline/municipal/status
   - POST /pipeline/municipal/reset
3. Convex functions work: listTexasCities, updateCityStatus, getCityByCityId, getTexasCityCoverage
4. Coverage report generates JSON and markdown formats
5. Test script validates Pinecone municipal filtering
</verification>

<success_criteria>
- 4 HTTP endpoints added for municipal pipeline
- 4 Convex functions for municipal jurisdiction tracking
- Coverage report shows all 20 target cities
- Test script validates TX-{cityId} jurisdiction filtering in Pinecone
- All exports available from municipal/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/05-municipal-data/05-06-SUMMARY.md`
</output>
