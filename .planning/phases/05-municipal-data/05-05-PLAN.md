---
phase: 05-municipal-data
plan: 05
type: execute
wave: 3
depends_on: ["05-02", "05-03", "05-04"]
files_modified:
  - apps/workers/src/municipal/fetch.ts
  - apps/workers/src/municipal/pipeline.ts
  - apps/workers/src/municipal/index.ts
autonomous: true

must_haves:
  truths:
    - "End-to-end pipeline: scrape -> store -> chunk -> embed -> index"
    - "Skip-and-log pattern continues processing after city failures"
    - "Municipal vectors indexed in Pinecone with TX-{cityId} jurisdiction"
  artifacts:
    - path: "apps/workers/src/municipal/fetch.ts"
      provides: "Batch fetching orchestrator with skip-and-log error handling"
      exports: ["fetchCity", "fetchAllEnabledCities"]
    - path: "apps/workers/src/municipal/pipeline.ts"
      provides: "End-to-end pipeline orchestrator with Pinecone indexing"
      exports: ["processCity", "processAllCities"]
      min_lines: 150
  key_links:
    - from: "apps/workers/src/municipal/pipeline.ts"
      to: "apps/workers/src/federal/embed.ts"
      via: "imports embedChunks"
      pattern: "import.*embedChunks"
    - from: "apps/workers/src/municipal/pipeline.ts"
      to: "apps/workers/src/pinecone.ts"
      via: "imports Pinecone client"
      pattern: "import.*pinecone"
---

<objective>
Create fetch orchestrator and end-to-end pipeline for municipal data processing.

Purpose: Orchestrate complete flow from Firecrawl scraping through Pinecone indexing with fault tolerance.
Output: Pipeline that processes 20 cities with checkpoint-based resumption and skip-and-log error handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-municipal-data/05-CONTEXT.md
@.planning/phases/05-municipal-data/05-RESEARCH.md
@.planning/phases/05-municipal-data/05-01-SUMMARY.md
@.planning/phases/05-municipal-data/05-02-SUMMARY.md
@.planning/phases/05-municipal-data/05-03-SUMMARY.md
@.planning/phases/05-municipal-data/05-04-SUMMARY.md
@apps/workers/src/counties/fetch.ts
@apps/workers/src/counties/pipeline.ts
@apps/workers/src/federal/embed.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fetch orchestrator</name>
  <files>apps/workers/src/municipal/fetch.ts</files>
  <action>
Create fetch orchestrator following county/fetch.ts patterns with skip-and-log error handling:

```typescript
import type { MunicipalOrdinance, MunicipalCityConfig, MunicipalBatchResult, MunicipalCheckpoint } from './types';
import { getEnabledCities, getCityById } from './cities';
import { scrapeCity, sleep, type Env as ScraperEnv } from './scraper';
import { parseMarkdownToOrdinances, validateOrdinances } from './parser';
import {
  storeMunicipalOrdinances,
  storeMunicipalMarkdown,
  getMunicipalMarkdown,
  saveMunicipalCheckpoint,
  loadMunicipalCheckpoint,
  type Env as StorageEnv,
} from './storage';

// Combined environment type
export interface Env extends ScraperEnv, StorageEnv {}

// Default delay between cities (Firecrawl recommends conservative usage)
const CITY_DELAY_MS = 2000;

// Default markdown cache TTL (30 days per 05-RESEARCH.md)
const MARKDOWN_CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000;

/**
 * Fetch and store ordinances for a single city
 *
 * Checks markdown cache first to minimize Firecrawl API costs.
 * Stores both raw markdown (cache) and parsed ordinances.
 *
 * @returns Number of ordinances stored
 */
export async function fetchCity(
  env: Env,
  city: MunicipalCityConfig,
  options?: { skipCache?: boolean }
): Promise<{ ordinances: MunicipalOrdinance[]; fromCache: boolean; creditsUsed: number }> {
  let markdown: string;
  let fromCache = false;
  let creditsUsed = 0;

  // Check markdown cache first (unless explicitly skipped)
  if (!options?.skipCache) {
    const cached = await getMunicipalMarkdown(env, city.cityId, MARKDOWN_CACHE_TTL_MS);
    if (cached) {
      console.log(`[Municipal] Using cached markdown for ${city.name} (scraped ${cached.scrapedAt.toISOString()})`);
      markdown = cached.markdown;
      fromCache = true;
    }
  }

  // Scrape if not cached
  if (!fromCache) {
    const scrapeResult = await scrapeCity(env, city);
    markdown = scrapeResult.markdown;
    creditsUsed = scrapeResult.metadata.creditsUsed;

    // Cache the markdown for future runs
    await storeMunicipalMarkdown(env, city.cityId, markdown, {
      title: scrapeResult.metadata.title,
      sourceUrl: scrapeResult.metadata.sourceUrl,
      scrapedAt: new Date(),
    });
  }

  // Parse markdown to ordinances
  const rawOrdinances = parseMarkdownToOrdinances(markdown, city);

  // Validate and filter
  const { valid: ordinances, warnings } = validateOrdinances(rawOrdinances, city);

  if (warnings.length > 0) {
    console.warn(`[Municipal] ${city.name} had ${warnings.length} parse warnings`);
  }

  // Store parsed ordinances
  await storeMunicipalOrdinances(env, ordinances);

  console.log(`[Municipal] Stored ${ordinances.length} ordinances for ${city.name} (cache: ${fromCache}, credits: ${creditsUsed})`);

  return { ordinances, fromCache, creditsUsed };
}

/**
 * Fetch all enabled cities with skip-and-log error handling
 *
 * Per user requirements (05-CONTEXT.md): "Skip and log on failure - mark city as 'needs manual review' and continue"
 *
 * @returns Batch result with successful, failed, and skipped cities
 */
export async function fetchAllEnabledCities(
  env: Env,
  options?: {
    resumeFromCheckpoint?: boolean;
    skipCache?: boolean;
    cityFilter?: string[]; // Optional: only process specific cities
  }
): Promise<MunicipalBatchResult> {
  const result: MunicipalBatchResult = {
    successful: [],
    failed: [],
    skipped: [],
    totalCreditsUsed: 0,
  };

  // Get enabled cities
  let cities = getEnabledCities();

  // Apply city filter if specified
  if (options?.cityFilter && options.cityFilter.length > 0) {
    cities = cities.filter(c => options.cityFilter!.includes(c.cityId) || options.cityFilter!.includes(c.name));
  }

  // Load checkpoint for resumption
  let checkpoint: MunicipalCheckpoint | null = null;
  if (options?.resumeFromCheckpoint) {
    checkpoint = await loadMunicipalCheckpoint(env);
    if (checkpoint) {
      console.log(`[Municipal] Resuming from checkpoint, ${checkpoint.processedCities.length} cities already processed`);
      // Filter out already-processed cities
      cities = cities.filter(c => !checkpoint!.processedCities.includes(c.cityId));
    }
  }

  // Process cities sequentially
  for (const city of cities) {
    try {
      console.log(`[Municipal] Processing ${city.name} (${cities.indexOf(city) + 1}/${cities.length})...`);

      const fetchResult = await fetchCity(env, city, { skipCache: options?.skipCache });
      result.successful.push(city.name);
      result.totalCreditsUsed += fetchResult.creditsUsed;

      // Update checkpoint after each successful city
      const processedCities = checkpoint?.processedCities ?? [];
      processedCities.push(city.cityId);
      await saveMunicipalCheckpoint(env, {
        lastProcessedCity: city.cityId,
        processedCities,
        lastUpdated: new Date().toISOString(),
      });

      // Rate limiting delay between cities
      await sleep(CITY_DELAY_MS);

    } catch (error) {
      // Skip and log pattern - continue with next city
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error(`[Municipal] FAILED ${city.name}:`, errorMessage);

      result.failed.push({
        city: city.name,
        error: errorMessage,
        timestamp: new Date().toISOString(),
      });

      // Continue to next city - don't fail the batch
    }
  }

  return result;
}

/**
 * Fetch a single city by ID or name
 *
 * Convenience wrapper for HTTP endpoint.
 */
export async function fetchSingleCity(
  env: Env,
  cityIdOrName: string,
  options?: { skipCache?: boolean }
): Promise<{ city: MunicipalCityConfig; ordinances: MunicipalOrdinance[]; creditsUsed: number }> {
  const city = getCityById(cityIdOrName) ?? getEnabledCities().find(c => c.name.toLowerCase() === cityIdOrName.toLowerCase());

  if (!city) {
    throw new Error(`City not found: ${cityIdOrName}`);
  }

  if (!city.enabled) {
    throw new Error(`City is disabled: ${city.name} (${city.skipReason ?? 'no reason given'})`);
  }

  const result = await fetchCity(env, city, options);
  return {
    city,
    ordinances: result.ordinances,
    creditsUsed: result.creditsUsed,
  };
}
```
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - no errors on fetch.ts</verify>
  <done>Fetch orchestrator with fetchCity, fetchAllEnabledCities, fetchSingleCity and skip-and-log handling</done>
</task>

<task type="auto">
  <name>Task 2: Create pipeline orchestrator</name>
  <files>apps/workers/src/municipal/pipeline.ts</files>
  <action>
Create pipeline orchestrator following county/pipeline.ts patterns:

```typescript
import type { MunicipalOrdinance, MunicipalChunk, MunicipalCityConfig, MunicipalBatchResult, MunicipalCheckpoint } from './types';
import { getEnabledCities, getCityById } from './cities';
import { fetchCity, type Env as FetchEnv } from './fetch';
import { chunkCity } from './chunk';
import { embedChunks } from '../federal/embed';
import { indexChunks, type Env as PineconeEnv } from '../pinecone';
import {
  saveMunicipalCheckpoint,
  loadMunicipalCheckpoint,
  clearMunicipalCheckpoint,
  getMunicipalStorageStats,
  type Env as StorageEnv,
} from './storage';
import { sleep } from './scraper';

// Combined environment type
export interface Env extends FetchEnv, PineconeEnv, StorageEnv {
  OPENAI_API_KEY: string;
}

// Delay between cities
const CITY_DELAY_MS = 2000;

/**
 * Result from processing a single city
 */
export interface MunicipalPipelineResult {
  city: string;
  cityId: string;
  ordinancesProcessed: number;
  chunksCreated: number;
  chunksEmbedded: number;
  chunksIndexed: number;
  creditsUsed: number;
  fromCache: boolean;
  duration: number;
}

/**
 * Result from processing all cities
 */
export interface MunicipalBatchPipelineResult {
  successful: MunicipalPipelineResult[];
  failed: Array<{ city: string; error: string; timestamp: string }>;
  skipped: string[];
  totalCreditsUsed: number;
  totalChunksIndexed: number;
  duration: number;
}

/**
 * Process a single city: fetch -> store -> chunk -> embed -> index
 *
 * @returns Pipeline result with statistics
 */
export async function processCity(
  env: Env,
  city: MunicipalCityConfig,
  options?: { skipCache?: boolean }
): Promise<MunicipalPipelineResult> {
  const startTime = Date.now();

  // Step 1: Fetch and store ordinances
  console.log(`[Municipal Pipeline] Step 1: Fetching ${city.name}...`);
  const fetchResult = await fetchCity(env, city, options);

  // Step 2: Chunk ordinances
  console.log(`[Municipal Pipeline] Step 2: Chunking ${fetchResult.ordinances.length} ordinances...`);
  const { chunks, stats } = chunkCity(fetchResult.ordinances, city);

  // Step 3: Generate embeddings
  console.log(`[Municipal Pipeline] Step 3: Embedding ${chunks.length} chunks...`);

  // Convert to CFRChunk-compatible format for embedChunks
  const chunksForEmbedding = chunks.map(chunk => ({
    chunkId: chunk.chunkId,
    text: chunk.text,
    // Other fields not needed for embedding
  }));

  const embeddedChunks = await embedChunks(env, chunksForEmbedding as any);

  // Step 4: Index in Pinecone
  console.log(`[Municipal Pipeline] Step 4: Indexing ${embeddedChunks.length} vectors...`);

  // Prepare vectors with municipal metadata
  // Jurisdiction format: TX-{cityId} (e.g., TX-houston)
  const vectors = embeddedChunks.map((embeddedChunk, i) => {
    const originalChunk = chunks[i];
    return {
      id: originalChunk.chunkId,
      values: embeddedChunk.embedding!,
      metadata: {
        text: originalChunk.text,
        citation: originalChunk.citation,
        sourceType: 'municipal' as const,
        jurisdiction: `TX-${city.cityId}`,
        sourceUrl: originalChunk.sourceUrl,
        hierarchy: originalChunk.hierarchy.join(' > '),
        cityId: city.cityId,
        cityName: city.name,
        chapter: originalChunk.chapter,
        section: originalChunk.section,
      },
    };
  });

  await indexChunks(env, vectors);

  const duration = Date.now() - startTime;

  console.log(`[Municipal Pipeline] Completed ${city.name} in ${duration}ms: ${chunks.length} chunks indexed`);

  return {
    city: city.name,
    cityId: city.cityId,
    ordinancesProcessed: fetchResult.ordinances.length,
    chunksCreated: chunks.length,
    chunksEmbedded: embeddedChunks.length,
    chunksIndexed: vectors.length,
    creditsUsed: fetchResult.creditsUsed,
    fromCache: fetchResult.fromCache,
    duration,
  };
}

/**
 * Process all enabled cities with checkpoint-based resumption
 *
 * Skip-and-log pattern: Individual city failures don't stop the batch.
 */
export async function processAllCities(
  env: Env,
  options?: {
    resumeFromCheckpoint?: boolean;
    skipCache?: boolean;
    cityFilter?: string[];
  }
): Promise<MunicipalBatchPipelineResult> {
  const startTime = Date.now();
  const result: MunicipalBatchPipelineResult = {
    successful: [],
    failed: [],
    skipped: [],
    totalCreditsUsed: 0,
    totalChunksIndexed: 0,
    duration: 0,
  };

  // Get cities to process
  let cities = getEnabledCities();

  if (options?.cityFilter && options.cityFilter.length > 0) {
    cities = cities.filter(c => options.cityFilter!.includes(c.cityId) || options.cityFilter!.includes(c.name));
  }

  // Load checkpoint for resumption
  let processedCities: string[] = [];
  if (options?.resumeFromCheckpoint) {
    const checkpoint = await loadMunicipalCheckpoint(env);
    if (checkpoint) {
      processedCities = checkpoint.processedCities;
      console.log(`[Municipal Pipeline] Resuming: ${processedCities.length} cities already processed`);
      cities = cities.filter(c => !processedCities.includes(c.cityId));
    }
  }

  // Process cities sequentially
  for (const city of cities) {
    try {
      console.log(`[Municipal Pipeline] Processing ${city.name} (${cities.indexOf(city) + 1}/${cities.length})...`);

      const pipelineResult = await processCity(env, city, { skipCache: options?.skipCache });
      result.successful.push(pipelineResult);
      result.totalCreditsUsed += pipelineResult.creditsUsed;
      result.totalChunksIndexed += pipelineResult.chunksIndexed;

      // Update checkpoint
      processedCities.push(city.cityId);
      await saveMunicipalCheckpoint(env, {
        lastProcessedCity: city.cityId,
        processedCities,
        lastUpdated: new Date().toISOString(),
      });

      // Delay between cities
      await sleep(CITY_DELAY_MS);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error(`[Municipal Pipeline] FAILED ${city.name}:`, errorMessage);

      result.failed.push({
        city: city.name,
        error: errorMessage,
        timestamp: new Date().toISOString(),
      });

      // Continue to next city
    }
  }

  result.duration = Date.now() - startTime;

  console.log(`[Municipal Pipeline] Batch complete: ${result.successful.length} succeeded, ${result.failed.length} failed in ${result.duration}ms`);

  return result;
}

/**
 * Process a single city by ID or name (HTTP endpoint helper)
 */
export async function processSingleCity(
  env: Env,
  cityIdOrName: string,
  options?: { skipCache?: boolean }
): Promise<MunicipalPipelineResult> {
  const city = getCityById(cityIdOrName) ?? getEnabledCities().find(c => c.name.toLowerCase() === cityIdOrName.toLowerCase());

  if (!city) {
    throw new Error(`City not found: ${cityIdOrName}`);
  }

  if (!city.enabled) {
    throw new Error(`City is disabled: ${city.name} (${city.skipReason ?? 'no reason given'})`);
  }

  return processCity(env, city, options);
}

/**
 * Get pipeline status
 */
export async function getMunicipalPipelineStatus(env: Env): Promise<{
  checkpoint: MunicipalCheckpoint | null;
  storage: Awaited<ReturnType<typeof getMunicipalStorageStats>>;
  enabledCities: number;
}> {
  const [checkpoint, storage] = await Promise.all([
    loadMunicipalCheckpoint(env),
    getMunicipalStorageStats(env),
  ]);

  return {
    checkpoint,
    storage,
    enabledCities: getEnabledCities().length,
  };
}

/**
 * Clear pipeline state for fresh run
 */
export async function resetMunicipalPipeline(env: Env): Promise<void> {
  await clearMunicipalCheckpoint(env);
  console.log('[Municipal Pipeline] Checkpoint cleared');
}
```
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - no errors on pipeline.ts</verify>
  <done>Pipeline orchestrator with processCity, processAllCities, and helper functions</done>
</task>

<task type="auto">
  <name>Task 3: Update module exports</name>
  <files>apps/workers/src/municipal/index.ts</files>
  <action>
Update municipal/index.ts to export all modules:

```typescript
export * from './types';
export * from './cities';
export * from './storage';
export * from './scraper';
export * from './parser';
export * from './chunk';
export * from './fetch';
export * from './pipeline';
```

Verify all major exports are available:
- Types: MunicipalOrdinance, MunicipalChunk, MunicipalCityConfig, MunicipalCheckpoint, MunicipalBatchResult
- Cities: TEXAS_CITIES, getEnabledCities, getCityById
- Storage: storeMunicipalOrdinance, saveMunicipalCheckpoint, etc.
- Scraper: scrapeMunicipalCode, scrapeCity
- Parser: parseMarkdownToOrdinances, extractSections
- Chunk: chunkMunicipalOrdinance, chunkCity
- Fetch: fetchCity, fetchAllEnabledCities
- Pipeline: processCity, processAllCities, MunicipalPipelineResult, MunicipalBatchPipelineResult
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - all exports compile</verify>
  <done>All municipal modules exported from index.ts</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `pnpm --filter @compliance-iq/workers exec tsc --noEmit`
2. Skip-and-log pattern: failed cities logged but don't stop batch
3. Checkpoint saved after each successful city
4. Pinecone metadata includes jurisdiction: TX-{cityId}
5. sourceType: 'municipal' for Pinecone filtering
6. Pipeline reuses embedChunks from federal/embed.ts
7. All functions exported from municipal/index.ts
</verification>

<success_criteria>
- processCity handles full pipeline: fetch -> chunk -> embed -> index
- processAllCities processes all 20 cities with checkpoint resumption
- Skip-and-log error handling continues after individual failures
- Pinecone vectors have TX-{cityId} jurisdiction (e.g., TX-houston)
- MunicipalPipelineResult and MunicipalBatchPipelineResult types defined
- All exports available from municipal/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/05-municipal-data/05-05-SUMMARY.md`
</output>
