---
phase: 05-municipal-data
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/workers/src/municipal/chunk.ts
  - apps/workers/src/municipal/index.ts
autonomous: true

must_haves:
  truths:
    - "Ordinances chunked at 1500 token limit with 15% overlap"
    - "Subsections used as primary split boundaries"
    - "Chunks include Bluebook citations and hierarchy breadcrumbs"
  artifacts:
    - path: "apps/workers/src/municipal/chunk.ts"
      provides: "Municipal chunking with subsection-aware splitting"
      exports: ["chunkMunicipalOrdinance", "chunkCity"]
      min_lines: 100
  key_links:
    - from: "apps/workers/src/municipal/chunk.ts"
      to: "apps/workers/src/lib/citations.ts"
      via: "imports generateMunicipalCitation"
      pattern: "import.*generateMunicipalCitation"
    - from: "apps/workers/src/municipal/chunk.ts"
      to: "apps/workers/src/lib/tokens.ts"
      via: "imports countTokens"
      pattern: "import.*countTokens"
---

<objective>
Create chunking module for municipal ordinances with subsection-aware splitting.

Purpose: Break ordinances into embeddable chunks while preserving legal structure and cross-references.
Output: Chunks with 1500 token limit, proper citations, and hierarchy metadata.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-municipal-data/05-CONTEXT.md
@.planning/phases/05-municipal-data/05-RESEARCH.md
@.planning/phases/05-municipal-data/05-01-SUMMARY.md
@apps/workers/src/counties/chunk.ts
@apps/workers/src/texas/chunk.ts
@apps/workers/src/lib/tokens.ts
@apps/workers/src/lib/citations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create municipal chunking module</name>
  <files>apps/workers/src/municipal/chunk.ts</files>
  <action>
Create chunking following county/chunk.ts and texas/chunk.ts patterns:

```typescript
import { countTokens } from '../lib/tokens';
import {
  generateMunicipalCitation,
  generateMunicipalChunkId,
  generateMunicipalHierarchy,
} from '../lib/citations';
import type { MunicipalOrdinance, MunicipalChunk, MunicipalCityConfig } from './types';
import { getCityById } from './cities';

// Chunking constants (matching federal/state/county patterns)
const MAX_TOKENS = 1500;
const OVERLAP_PERCENT = 0.15;

/**
 * Chunk a single municipal ordinance into embeddable segments
 *
 * Strategy:
 * 1. If ordinance fits in single chunk, use as-is
 * 2. If ordinance has subsections, split at subsection boundaries
 * 3. If no subsections or subsections too large, split by paragraphs with overlap
 *
 * Per 05-RESEARCH.md pitfall #5: Parse subsections BEFORE chunking to preserve structure.
 */
export function chunkMunicipalOrdinance(
  ordinance: MunicipalOrdinance,
  city: MunicipalCityConfig
): MunicipalChunk[] {
  const chunks: MunicipalChunk[] = [];

  // Check if full ordinance fits in one chunk
  const fullText = buildOrdinanceText(ordinance);
  const fullTokens = countTokens(fullText);

  if (fullTokens <= MAX_TOKENS) {
    // Single chunk - no splitting needed
    chunks.push(createChunk(ordinance, city, fullText, 0));
    return chunks;
  }

  // Try subsection-based splitting first
  if (ordinance.subsections && ordinance.subsections.length > 0) {
    const subsectionChunks = chunkBySubsections(ordinance, city);
    if (subsectionChunks.length > 0) {
      return subsectionChunks;
    }
  }

  // Fall back to paragraph-based splitting with overlap
  return chunkByParagraphs(ordinance, city);
}

/**
 * Build full text representation of ordinance
 */
function buildOrdinanceText(ordinance: MunicipalOrdinance): string {
  let text = `Section ${ordinance.section}`;
  if (ordinance.heading) {
    text += ` - ${ordinance.heading}`;
  }
  text += '\n\n' + ordinance.text;

  // Include subsections if present
  if (ordinance.subsections && ordinance.subsections.length > 0) {
    text += '\n\n';
    for (const sub of ordinance.subsections) {
      text += `${sub.id} ${sub.text}\n`;
    }
  }

  return text;
}

/**
 * Chunk by subsection boundaries
 *
 * Groups consecutive subsections until MAX_TOKENS reached.
 */
function chunkBySubsections(
  ordinance: MunicipalOrdinance,
  city: MunicipalCityConfig
): MunicipalChunk[] {
  const chunks: MunicipalChunk[] = [];
  let currentText = `Section ${ordinance.section}`;
  if (ordinance.heading) {
    currentText += ` - ${ordinance.heading}`;
  }
  currentText += '\n\n';

  let chunkIndex = 0;

  for (const subsection of ordinance.subsections!) {
    const subsectionText = `${subsection.id} ${subsection.text}\n`;
    const combinedText = currentText + subsectionText;
    const combinedTokens = countTokens(combinedText);

    if (combinedTokens > MAX_TOKENS && currentText.length > 50) {
      // Save current chunk and start new one
      chunks.push(createChunk(ordinance, city, currentText.trim(), chunkIndex));
      chunkIndex++;

      // Start new chunk with section header for context
      currentText = `Section ${ordinance.section} (continued)`;
      if (ordinance.heading) {
        currentText += ` - ${ordinance.heading}`;
      }
      currentText += '\n\n' + subsectionText;
    } else {
      currentText = combinedText;
    }
  }

  // Don't forget the last chunk
  if (currentText.length > 50) {
    chunks.push(createChunk(ordinance, city, currentText.trim(), chunkIndex));
  }

  return chunks;
}

/**
 * Chunk by paragraphs with overlap
 *
 * Used when no subsections or subsection splitting not possible.
 * Implements 15% overlap for cross-reference preservation.
 */
function chunkByParagraphs(
  ordinance: MunicipalOrdinance,
  city: MunicipalCityConfig
): MunicipalChunk[] {
  const chunks: MunicipalChunk[] = [];
  const paragraphs = ordinance.text.split(/\n\n+/).filter(p => p.trim().length > 0);

  if (paragraphs.length === 0) {
    // Edge case: no paragraphs, use heading only
    return [createChunk(ordinance, city, `Section ${ordinance.section} - ${ordinance.heading}`, 0)];
  }

  let currentParagraphs: string[] = [];
  let chunkIndex = 0;
  let overlapParagraphs: string[] = [];

  for (let i = 0; i < paragraphs.length; i++) {
    const para = paragraphs[i];
    const testText = buildParagraphChunkText(ordinance, [...currentParagraphs, para], chunkIndex > 0);
    const testTokens = countTokens(testText);

    if (testTokens > MAX_TOKENS && currentParagraphs.length > 0) {
      // Save current chunk
      const chunkText = buildParagraphChunkText(ordinance, currentParagraphs, chunkIndex > 0);
      chunks.push(createChunk(ordinance, city, chunkText, chunkIndex));
      chunkIndex++;

      // Calculate overlap (15% of current paragraphs)
      const overlapCount = Math.max(1, Math.ceil(currentParagraphs.length * OVERLAP_PERCENT));
      overlapParagraphs = currentParagraphs.slice(-overlapCount);

      // Start new chunk with overlap
      currentParagraphs = [...overlapParagraphs, para];
    } else {
      currentParagraphs.push(para);
    }
  }

  // Don't forget the last chunk
  if (currentParagraphs.length > 0) {
    const chunkText = buildParagraphChunkText(ordinance, currentParagraphs, chunkIndex > 0);
    chunks.push(createChunk(ordinance, city, chunkText, chunkIndex));
  }

  return chunks;
}

/**
 * Build text for paragraph-based chunk
 */
function buildParagraphChunkText(
  ordinance: MunicipalOrdinance,
  paragraphs: string[],
  isContinuation: boolean
): string {
  let header = `Section ${ordinance.section}`;
  if (isContinuation) header += ' (continued)';
  if (ordinance.heading) header += ` - ${ordinance.heading}`;

  return header + '\n\n' + paragraphs.join('\n\n');
}

/**
 * Create a MunicipalChunk with all required metadata
 */
function createChunk(
  ordinance: MunicipalOrdinance,
  city: MunicipalCityConfig,
  text: string,
  chunkIndex: number
): MunicipalChunk {
  return {
    chunkId: generateMunicipalChunkId(
      city.cityId,
      ordinance.chapter,
      ordinance.section,
      chunkIndex
    ),
    cityId: city.cityId,
    chapter: ordinance.chapter,
    section: ordinance.section,
    text,
    citation: generateMunicipalCitation(city.name, ordinance.section),
    hierarchy: generateMunicipalHierarchy(city.name, ordinance.chapter, ordinance.section),
    sourceUrl: ordinance.sourceUrl,
    tokenCount: countTokens(text),
  };
}

/**
 * Chunk all ordinances for a city
 *
 * @returns Array of all chunks with statistics
 */
export function chunkCity(
  ordinances: MunicipalOrdinance[],
  city: MunicipalCityConfig
): { chunks: MunicipalChunk[]; stats: ChunkStats } {
  const chunks: MunicipalChunk[] = [];
  let totalTokens = 0;
  let minTokens = Infinity;
  let maxTokens = 0;

  for (const ordinance of ordinances) {
    const ordinanceChunks = chunkMunicipalOrdinance(ordinance, city);
    for (const chunk of ordinanceChunks) {
      chunks.push(chunk);
      totalTokens += chunk.tokenCount;
      minTokens = Math.min(minTokens, chunk.tokenCount);
      maxTokens = Math.max(maxTokens, chunk.tokenCount);
    }
  }

  return {
    chunks,
    stats: {
      totalChunks: chunks.length,
      totalOrdinances: ordinances.length,
      totalTokens,
      avgTokens: chunks.length > 0 ? Math.round(totalTokens / chunks.length) : 0,
      minTokens: minTokens === Infinity ? 0 : minTokens,
      maxTokens,
    },
  };
}

/**
 * Chunk statistics for monitoring
 */
export interface ChunkStats {
  totalChunks: number;
  totalOrdinances: number;
  totalTokens: number;
  avgTokens: number;
  minTokens: number;
  maxTokens: number;
}

/**
 * Get chunk statistics for a city (without creating chunks)
 *
 * Useful for dry-run validation.
 */
export function getMunicipalChunkStats(
  ordinances: MunicipalOrdinance[],
  city: MunicipalCityConfig
): ChunkStats {
  const { stats } = chunkCity(ordinances, city);
  return stats;
}
```
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - no errors on chunk.ts</verify>
  <done>Municipal chunking module with subsection-aware splitting, 1500 token limit, 15% overlap</done>
</task>

<task type="auto">
  <name>Task 2: Update module exports</name>
  <files>apps/workers/src/municipal/index.ts</files>
  <action>
Update municipal/index.ts to export chunking module:

```typescript
export * from './types';
export * from './cities';
export * from './storage';
export * from './chunk';
```

Exports to verify:
- chunkMunicipalOrdinance
- chunkCity
- getMunicipalChunkStats
- ChunkStats interface
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - index.ts compiles with chunk exports</verify>
  <done>Chunking functions exported from municipal/index.ts</done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `pnpm --filter @compliance-iq/workers exec tsc --noEmit`
2. Chunking uses 1500 token MAX_TOKENS constant
3. Overlap is 15% (OVERLAP_PERCENT = 0.15)
4. Subsection splitting attempted before paragraph splitting
5. All chunks include Bluebook citation and hierarchy
6. ChunkStats tracks totalChunks, totalTokens, avgTokens, minTokens, maxTokens
</verification>

<success_criteria>
- chunkMunicipalOrdinance handles three cases: single chunk, subsection split, paragraph split
- chunkCity processes all ordinances for a city with statistics
- getMunicipalChunkStats for dry-run validation
- 1500 token limit and 15% overlap match federal/state/county patterns
- Citations generated in Bluebook format via generateMunicipalCitation
- All exports available from municipal/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/05-municipal-data/05-04-SUMMARY.md`
</output>
