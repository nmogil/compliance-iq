---
phase: 05-municipal-data
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/workers/package.json
  - apps/workers/src/municipal/scraper.ts
  - apps/workers/src/municipal/parser.ts
  - apps/workers/src/municipal/index.ts
autonomous: true

user_setup:
  - service: firecrawl
    why: "JavaScript rendering and scraping for municipal code sites"
    env_vars:
      - name: FIRECRAWL_API_KEY
        source: "Firecrawl Dashboard -> API Keys (firecrawl.dev/dashboard)"
    dashboard_config: []

must_haves:
  truths:
    - "Firecrawl SDK scrapes JavaScript-rendered municipal sites"
    - "Markdown output parsed into structured ordinance sections"
    - "Failed scrapes logged with detailed error context"
  artifacts:
    - path: "apps/workers/src/municipal/scraper.ts"
      provides: "Firecrawl scraping with error handling and rate limiting"
      exports: ["scrapeMunicipalCode", "scrapeCity"]
    - path: "apps/workers/src/municipal/parser.ts"
      provides: "Markdown-to-ordinance parsing with section detection"
      exports: ["parseMarkdownToOrdinances", "extractSections"]
  key_links:
    - from: "apps/workers/src/municipal/scraper.ts"
      to: "FIRECRAWL_API_KEY"
      via: "environment variable"
      pattern: "env\\.FIRECRAWL_API_KEY"
    - from: "apps/workers/src/municipal/parser.ts"
      to: "marked"
      via: "import"
      pattern: "import.*marked"
---

<objective>
Implement Firecrawl-based scraper and markdown parser for municipal code sites.

Purpose: Enable scraping of JavaScript-rendered Municode and American Legal sites with unified Firecrawl approach.
Output: Scraper module that fetches pages and parser that converts markdown to structured ordinances.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-municipal-data/05-CONTEXT.md
@.planning/phases/05-municipal-data/05-RESEARCH.md
@.planning/phases/05-municipal-data/05-01-SUMMARY.md
@apps/workers/src/municipal/types.ts
@apps/workers/src/municipal/cities.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Firecrawl and marked dependencies</name>
  <files>apps/workers/package.json</files>
  <action>
Add Firecrawl SDK and marked parser to workers package:

```bash
cd apps/workers && pnpm add @mendable/firecrawl-js marked
```

Dependencies to add:
- @mendable/firecrawl-js: ^4.3.0 (or latest 4.x) - Firecrawl Node SDK for JavaScript rendering
- marked: ^15.0.0 (or latest 15.x) - Markdown parser with custom renderer support

Verify package.json includes both dependencies after installation.
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec -- node -e "require('@mendable/firecrawl-js'); require('marked'); console.log('OK')"`</verify>
  <done>@mendable/firecrawl-js and marked installed in workers package</done>
</task>

<task type="auto">
  <name>Task 2: Create Firecrawl scraper module</name>
  <files>apps/workers/src/municipal/scraper.ts</files>
  <action>
Create scraper using Firecrawl SDK (per 05-RESEARCH.md patterns):

```typescript
import Firecrawl from '@mendable/firecrawl-js';
import type { MunicipalCityConfig } from './types';

// Export Env type for Cloudflare Workers binding
export interface Env {
  FIRECRAWL_API_KEY: string;
  // ... other bindings
}

/**
 * Result from Firecrawl scrape operation
 */
export interface FirecrawlScrapeResult {
  markdown: string;
  metadata: {
    title: string;
    sourceUrl: string;
    statusCode: number;
    creditsUsed: number;
  };
}

/**
 * Scrape a municipal code page using Firecrawl
 *
 * Firecrawl handles JavaScript rendering, anti-bot protection, and proxy rotation.
 * Returns markdown content for parsing.
 */
export async function scrapeMunicipalCode(
  env: Env,
  city: MunicipalCityConfig
): Promise<FirecrawlScrapeResult> {
  const app = new Firecrawl({ apiKey: env.FIRECRAWL_API_KEY });

  const result = await app.scrape({
    url: city.baseUrl,
    formats: ['markdown'],
    onlyMainContent: city.firecrawlConfig?.onlyMainContent ?? true,
    waitFor: city.firecrawlConfig?.waitFor ?? 2000,
    timeout: 30000, // 30 second max
  });

  // Handle potential error states
  if (!result || !result.markdown) {
    throw new Error(`Firecrawl returned empty result for ${city.name}`);
  }

  return {
    markdown: result.markdown,
    metadata: {
      title: result.metadata?.title ?? city.name,
      sourceUrl: result.metadata?.sourceURL ?? city.baseUrl,
      statusCode: result.metadata?.statusCode ?? 200,
      creditsUsed: 1, // Standard scrape = 1 credit
    },
  };
}

/**
 * Scrape a city with error handling and logging
 *
 * Returns result or throws with detailed error context per user requirements
 * (skip and log on failure pattern).
 */
export async function scrapeCity(
  env: Env,
  city: MunicipalCityConfig
): Promise<FirecrawlScrapeResult> {
  console.log(`[Municipal] Scraping ${city.name} (${city.platform})...`);

  try {
    const result = await scrapeMunicipalCode(env, city);
    console.log(`[Municipal] Scraped ${city.name}: ${result.markdown.length} chars, ${result.metadata.creditsUsed} credits`);
    return result;
  } catch (error) {
    // Log detailed error context for debugging (per 05-RESEARCH.md pitfall #4)
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error(`[Municipal] Failed to scrape ${city.name}:`, {
      city: city.name,
      cityId: city.cityId,
      platform: city.platform,
      baseUrl: city.baseUrl,
      error: errorMessage,
      timestamp: new Date().toISOString(),
    });
    throw error;
  }
}

/**
 * Rate-limited sleep between requests
 *
 * Firecrawl handles internal rate limiting, but we add conservative delays
 * between cities to avoid overwhelming the service.
 */
export async function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

Key implementation notes:
- Use Firecrawl's `onlyMainContent: true` to filter nav/footer
- Platform-specific waitFor from city config (Municode: 2000ms, American Legal: 1000ms)
- Detailed error logging captures city metadata for debugging failed scrapes
- Export Env interface for Workers environment typing
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - no errors on scraper.ts</verify>
  <done>Firecrawl scraper module with scrapeMunicipalCode, scrapeCity, sleep functions</done>
</task>

<task type="auto">
  <name>Task 3: Create markdown parser module</name>
  <files>apps/workers/src/municipal/parser.ts, apps/workers/src/municipal/index.ts</files>
  <action>
Create parser using marked library (per 05-RESEARCH.md patterns):

```typescript
import { marked } from 'marked';
import type { MunicipalOrdinance, MunicipalCityConfig } from './types';

/**
 * Parsed section from markdown
 */
interface ParsedSection {
  chapter: string;
  section: string;
  heading: string;
  text: string;
  subsections: Array<{ id: string; text: string }>;
}

/**
 * Parse Firecrawl markdown output into structured ordinance sections
 *
 * Uses marked custom renderer to track heading levels and accumulate
 * section content. Handles both Municode and American Legal structure variations.
 */
export function parseMarkdownToOrdinances(
  markdown: string,
  city: MunicipalCityConfig
): MunicipalOrdinance[] {
  const sections: ParsedSection[] = [];
  let currentChapter = '';
  let currentSection: ParsedSection | null = null;

  // Configure marked with custom renderer
  const renderer = {
    heading(text: string, level: number) {
      // Chapter heading detection (level 1-2)
      const chapterMatch = text.match(/(?:Chapter|CHAPTER|Ch\.?)\s*(\d+[A-Z]?)/i);
      if (chapterMatch && level <= 2) {
        currentChapter = chapterMatch[1];
        return '';
      }

      // Section heading detection (level 3-4)
      // Multiple patterns for different municipal code formats:
      // "Sec. 1-2 - Title", "Section 1.02 Title", "ยง 1-2. Title"
      const sectionPatterns = [
        /(?:Sec\.|Section|ยง)\s*([\d.-]+)[\s:-]+(.+)/i,
        /^([\d.-]+)\.\s+(.+)/,  // "1-2. Title" format
      ];

      for (const pattern of sectionPatterns) {
        const match = text.match(pattern);
        if (match && level >= 3) {
          // Save previous section
          if (currentSection) {
            sections.push(currentSection);
          }

          currentSection = {
            chapter: currentChapter || '0',
            section: match[1],
            heading: match[2]?.trim() || '',
            text: '',
            subsections: [],
          };
          return '';
        }
      }

      return '';
    },

    paragraph(text: string) {
      if (currentSection) {
        currentSection.text += text + '\n\n';
      }
      return '';
    },

    list(body: string) {
      if (!currentSection) return '';

      // Detect subsections in lettered/numbered lists
      // Patterns: "(a)", "(1)", "(i)", "a.", "1."
      const subsectionPatterns = [
        /\(([a-z])\)\s*([^(]+)/gi,  // (a) text
        /\((\d+)\)\s*([^(]+)/gi,    // (1) text
        /\(([ivx]+)\)\s*([^(]+)/gi, // (i) text
      ];

      for (const pattern of subsectionPatterns) {
        const matches = body.matchAll(pattern);
        for (const match of matches) {
          currentSection.subsections.push({
            id: `(${match[1]})`,
            text: match[2].trim(),
          });
        }
      }

      // Also accumulate as text for fallback
      currentSection.text += body + '\n\n';
      return '';
    },

    listitem(text: string) {
      // Individual list items accumulated via list()
      return text;
    },
  };

  // Apply custom renderer
  marked.use({ renderer });

  // Parse markdown (renderer callbacks capture structure)
  marked.parse(markdown);

  // Push final section
  if (currentSection) {
    sections.push(currentSection);
  }

  // Convert parsed sections to MunicipalOrdinance objects
  return sections.map(section => ({
    cityId: city.cityId,
    chapter: section.chapter,
    section: section.section,
    heading: section.heading,
    text: section.text.trim(),
    subsections: section.subsections,
    sourceUrl: city.baseUrl,
    scrapedAt: new Date(),
  }));
}

/**
 * Extract section numbers from markdown for TOC building
 *
 * Lighter-weight parsing for discovering what sections exist.
 */
export function extractSections(markdown: string): string[] {
  const sections: string[] = [];
  const sectionPattern = /(?:Sec\.|Section|ยง)\s*([\d.-]+)/gi;

  let match;
  while ((match = sectionPattern.exec(markdown)) !== null) {
    if (!sections.includes(match[1])) {
      sections.push(match[1]);
    }
  }

  return sections.sort((a, b) => {
    // Numeric sort handling multi-part section numbers (e.g., "1-2", "1-10")
    const partsA = a.split(/[.-]/).map(Number);
    const partsB = b.split(/[.-]/).map(Number);

    for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
      const diff = (partsA[i] || 0) - (partsB[i] || 0);
      if (diff !== 0) return diff;
    }
    return 0;
  });
}

/**
 * Validate parsed ordinances have expected structure
 *
 * Logs warnings for sections without expected fields (per pitfall #2).
 */
export function validateOrdinances(
  ordinances: MunicipalOrdinance[],
  city: MunicipalCityConfig
): { valid: MunicipalOrdinance[]; warnings: string[] } {
  const valid: MunicipalOrdinance[] = [];
  const warnings: string[] = [];

  for (const ordinance of ordinances) {
    if (!ordinance.section) {
      warnings.push(`Missing section number in ${city.name}`);
      continue;
    }
    if (!ordinance.text || ordinance.text.length < 10) {
      warnings.push(`Empty/short text for section ${ordinance.section} in ${city.name}`);
      // Still include - may be valid short section
    }
    valid.push(ordinance);
  }

  if (warnings.length > 0) {
    console.warn(`[Municipal] Parse warnings for ${city.name}:`, warnings);
  }

  return { valid, warnings };
}
```

Update municipal/index.ts to export new modules:
```typescript
export * from './types';
export * from './cities';
export * from './scraper';
export * from './parser';
```
  </action>
  <verify>Run: `pnpm --filter @compliance-iq/workers exec tsc --noEmit` - no errors on parser.ts and index.ts</verify>
  <done>Markdown parser with parseMarkdownToOrdinances, extractSections, validateOrdinances functions</done>
</task>

</tasks>

<verification>
1. Dependencies installed: @mendable/firecrawl-js and marked in workers/package.json
2. TypeScript compiles: `pnpm --filter @compliance-iq/workers exec tsc --noEmit`
3. Scraper exports: scrapeMunicipalCode, scrapeCity, sleep
4. Parser exports: parseMarkdownToOrdinances, extractSections, validateOrdinances
5. All exports available from municipal/index.ts
</verification>

<success_criteria>
- Firecrawl SDK and marked dependencies installed
- Scraper handles both Municode and American Legal via unified Firecrawl approach
- Parser converts markdown to MunicipalOrdinance[] with section/subsection detection
- Error logging includes city metadata for debugging failed scrapes
- All functions exported from municipal/index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/05-municipal-data/05-02-SUMMARY.md`
</output>
