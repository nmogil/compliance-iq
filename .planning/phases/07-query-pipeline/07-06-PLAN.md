---
phase: 07-query-pipeline
plan: 06
type: execute
wave: 3
depends_on: ["07-05"]
files_modified:
  - apps/convex/convex/queries/getQuery.ts
  - apps/convex/convex/queries/getHistory.ts
  - scripts/test-query.ts
autonomous: true
user_setup:
  - service: geocodio
    why: "Address-to-jurisdiction resolution"
    env_vars:
      - name: GEOCODIO_API_KEY
        source: "https://dash.geocod.io/ -> API Keys"
    account_setup:
      - task: "Create free Geocodio account (2500 free lookups/day)"
        url: "https://dash.geocod.io/register"
  - service: anthropic
    why: "Claude API for answer generation"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "https://console.anthropic.com/settings/keys"

must_haves:
  truths:
    - "Query can be retrieved by conversation ID"
    - "User conversation history is queryable"
    - "Test script validates environment variables before execution"
    - "Test script validates end-to-end pipeline"
  artifacts:
    - path: "apps/convex/convex/queries/getQuery.ts"
      provides: "Query retrieval by conversation"
      exports: ["getQueryByConversation", "getLatestQuery"]
    - path: "apps/convex/convex/queries/getHistory.ts"
      provides: "User conversation history"
      exports: ["getUserHistory"]
    - path: "scripts/test-query.ts"
      provides: "End-to-end query pipeline test"
  key_links:
    - from: "scripts/test-query.ts"
      to: "Convex action"
      via: "processQuery call"
      pattern: "convex.action"
---

<objective>
Create query retrieval functions and end-to-end test script.

Purpose: Enables query result retrieval for display and testing. Test script validates the complete pipeline works end-to-end before Phase 8 integration.

Output:
- Convex queries for retrieving query results and history
- CLI test script for manual pipeline validation
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-query-pipeline/07-CONTEXT.md
@.planning/phases/07-query-pipeline/07-05-SUMMARY.md
@apps/convex/convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query retrieval functions</name>
  <files>apps/convex/convex/queries/getQuery.ts, apps/convex/convex/queries/getHistory.ts</files>
  <action>
Create query retrieval functions:

**apps/convex/convex/queries/getQuery.ts:**
```typescript
import { query } from '../_generated/server';
import { v } from 'convex/values';

/**
 * Get all messages for a conversation (query + answer pairs)
 */
export const getQueryByConversation = query({
  args: {
    conversationId: v.id('conversations')
  },
  handler: async (ctx, args) => {
    const conversation = await ctx.db.get(args.conversationId);
    if (!conversation) {
      return null;
    }

    const messages = await ctx.db
      .query('messages')
      .withIndex('by_conversation', q => q.eq('conversationId', args.conversationId))
      .order('asc')
      .collect();

    return {
      conversation,
      messages
    };
  }
});

/**
 * Get the most recent query (last conversation with messages)
 */
export const getLatestQuery = query({
  args: {},
  handler: async (ctx) => {
    // Get most recent conversation
    const conversations = await ctx.db
      .query('conversations')
      .order('desc')
      .take(1);

    if (conversations.length === 0) {
      return null;
    }

    const conversation = conversations[0];

    const messages = await ctx.db
      .query('messages')
      .withIndex('by_conversation', q => q.eq('conversationId', conversation._id))
      .order('asc')
      .collect();

    return {
      conversation,
      messages
    };
  }
});
```

**apps/convex/convex/queries/getHistory.ts:**
```typescript
import { query } from '../_generated/server';
import { v } from 'convex/values';

/**
 * Get user's conversation history
 * Note: userId is placeholder until auth in Phase 8
 */
export const getUserHistory = query({
  args: {
    userId: v.optional(v.string()),
    limit: v.optional(v.number())
  },
  handler: async (ctx, args) => {
    const limit = args.limit ?? 20;

    // Get conversations (optionally filtered by user)
    let conversationsQuery = ctx.db.query('conversations');

    if (args.userId) {
      conversationsQuery = conversationsQuery.withIndex('by_user', q =>
        q.eq('userId', args.userId)
      );
    }

    const conversations = await conversationsQuery
      .order('desc')
      .take(limit);

    // Get first message of each conversation for preview
    const history = await Promise.all(
      conversations.map(async (conv) => {
        const messages = await ctx.db
          .query('messages')
          .withIndex('by_conversation', q => q.eq('conversationId', conv._id))
          .order('asc')
          .take(1);

        return {
          conversation: conv,
          preview: messages[0]?.content?.substring(0, 100) ?? ''
        };
      })
    );

    return history;
  }
});
```
  </action>
  <verify>
```bash
cd apps/convex && npx tsc --noEmit
```
  </verify>
  <done>Query retrieval functions return conversations with messages</done>
</task>

<task type="auto">
  <name>Task 2: Create end-to-end test script</name>
  <files>scripts/test-query.ts</files>
  <action>
Create CLI test script in scripts/test-query.ts:

```typescript
/**
 * End-to-end Query Pipeline Test
 *
 * Tests the complete RAG pipeline:
 * 1. Geocode address to jurisdictions
 * 2. Embed query
 * 3. Retrieve relevant chunks from Pinecone
 * 4. Generate answer with Claude
 * 5. Parse and validate response
 *
 * Usage:
 *   npx tsx scripts/test-query.ts "What permits do I need to sell alcohol?" "1000 Main St, Houston, TX 77002"
 *   npx tsx scripts/test-query.ts "What are the food safety requirements?"
 */

import 'dotenv/config';
import { ConvexHttpClient } from 'convex/browser';
import { api } from '../apps/convex/convex/_generated/api';

// Validate all required environment variables before proceeding
function validateEnvironment(): void {
  const required = [
    { name: 'CONVEX_URL', hint: 'Set in .env or export CONVEX_URL=https://your-deployment.convex.cloud' },
    { name: 'OPENAI_API_KEY', hint: 'Get from https://platform.openai.com/api-keys' },
    { name: 'PINECONE_API_KEY', hint: 'Get from https://app.pinecone.io/ -> API Keys' },
    { name: 'ANTHROPIC_API_KEY', hint: 'Get from https://console.anthropic.com/settings/keys' }
  ];

  const missing = required.filter(v => !process.env[v.name]);

  if (missing.length > 0) {
    console.error('ERROR: Missing required environment variables:\n');
    missing.forEach(v => {
      console.error(`  ${v.name}`);
      console.error(`    ${v.hint}\n`);
    });
    process.exit(1);
  }

  // Optional: warn about GEOCODIO_API_KEY
  if (!process.env.GEOCODIO_API_KEY) {
    console.warn('WARNING: GEOCODIO_API_KEY not set - address geocoding will fall back to federal-only\n');
  }
}

async function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('Usage: npx tsx scripts/test-query.ts "<question>" ["<address>"]');
    console.log('');
    console.log('Examples:');
    console.log('  npx tsx scripts/test-query.ts "What permits do I need to sell alcohol?" "1000 Main St, Houston, TX 77002"');
    console.log('  npx tsx scripts/test-query.ts "What are the food safety requirements for retail?"');
    process.exit(1);
  }

  // Validate environment before making API calls
  validateEnvironment();

  const question = args[0];
  const address = args[1];

  const convexUrl = process.env.CONVEX_URL!;

  console.log('=== ComplianceIQ Query Pipeline Test ===');
  console.log('');
  console.log(`Question: ${question}`);
  if (address) {
    console.log(`Address: ${address}`);
  }
  console.log('');

  const client = new ConvexHttpClient(convexUrl);

  console.log('Processing query...');
  const startTime = Date.now();

  try {
    const result = await client.action(api.actions.query.processQuery, {
      question,
      address
    });

    const elapsed = Date.now() - startTime;

    console.log('');
    console.log('=== Results ===');
    console.log('');
    console.log(`Jurisdictions: ${result.jurisdictions.join(', ')}`);
    console.log(`Chunks Retrieved: ${result.retrievedChunks.length}`);
    console.log(`Processing Time: ${result.processingTimeMs}ms`);
    console.log(`Confidence: ${result.answer.confidence.level} (${result.answer.confidence.score.toFixed(2)})`);
    console.log(`Confidence Reason: ${result.answer.confidence.reason}`);
    console.log('');

    console.log('=== Answer Summary ===');
    console.log(result.answer.summary);
    console.log('');

    console.log('=== Citations ===');
    result.answer.citations.forEach((c, i) => {
      console.log(`[${c.id}] ${c.citation} (${c.jurisdiction})`);
    });
    console.log('');

    if (result.answer.permits.length > 0) {
      console.log('=== Required Permits ===');
      result.answer.permits.forEach((p, i) => {
        console.log(`${i + 1}. ${p.name}`);
        console.log(`   Agency: ${p.issuingAgency}`);
        console.log(`   Jurisdiction: ${p.jurisdiction}`);
        if (p.url) {
          console.log(`   URL: ${p.url}`);
        }
        console.log(`   Reference: ${p.citation}`);
        console.log('');
      });
    } else {
      console.log('No specific permits identified in response.');
    }

    console.log('=== Full Answer ===');
    console.log('');
    // Print full answer from first assistant message
    console.log(result.answer.sections.map(s =>
      `### ${s.level.charAt(0).toUpperCase() + s.level.slice(1)}\n${s.content}`
    ).join('\n\n'));

    console.log('');
    console.log(`Query ID: ${result.queryId}`);
    console.log(`Total time: ${elapsed}ms`);

  } catch (error) {
    console.error('');
    console.error('ERROR:', error);
    process.exit(1);
  }
}

main();
```

**Add script to package.json:**
```json
{
  "scripts": {
    "test:query": "npx tsx scripts/test-query.ts"
  }
}
```
  </action>
  <verify>
```bash
npx tsc --noEmit scripts/test-query.ts 2>&1 || echo "Note: Script may show import errors until convex generates types"
```
  </verify>
  <done>Test script exercises full query pipeline and displays results</done>
</task>

<task type="auto">
  <name>Task 3: Document environment variables</name>
  <files>apps/convex/.env.example</files>
  <action>
Create or update apps/convex/.env.example with required environment variables:

```env
# Convex deployment URL
CONVEX_URL=https://your-deployment.convex.cloud

# OpenAI API key for embeddings
# Get from: https://platform.openai.com/api-keys
OPENAI_API_KEY=sk-...

# Pinecone API key for vector search
# Get from: https://app.pinecone.io/ -> API Keys
PINECONE_API_KEY=...

# Anthropic API key for Claude
# Get from: https://console.anthropic.com/settings/keys
ANTHROPIC_API_KEY=sk-ant-...

# Geocodio API key for address resolution (optional)
# Get from: https://dash.geocod.io/ -> API Keys
# Free tier: 2500 lookups/day
GEOCODIO_API_KEY=...
```

Also update root .env.example if it exists to include CONVEX_URL.
  </action>
  <verify>File apps/convex/.env.example exists with all required keys documented</verify>
  <done>Environment variable documentation complete</done>
</task>

</tasks>

<verification>
1. apps/convex/convex/queries/getQuery.ts exists with getQueryByConversation, getLatestQuery
2. apps/convex/convex/queries/getHistory.ts exists with getUserHistory
3. scripts/test-query.ts exists and is executable
4. apps/convex/.env.example documents all required API keys
5. TypeScript compiles: `cd apps/convex && npx tsc --noEmit`
</verification>

<success_criteria>
- Query results retrievable by conversation ID
- User history shows recent conversations with previews
- Test script exercises full pipeline with CLI arguments
- Environment variables documented for all external services
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-query-pipeline/07-06-SUMMARY.md`
</output>
