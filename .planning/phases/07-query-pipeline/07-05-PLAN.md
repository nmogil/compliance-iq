---
phase: 07-query-pipeline
plan: 05
type: execute
wave: 3
depends_on: ["07-01", "07-02", "07-03", "07-04"]
files_modified:
  - apps/convex/convex/actions/query.ts
  - apps/convex/convex/mutations/saveQuery.ts
  - apps/convex/convex/schema.ts
autonomous: true

must_haves:
  truths:
    - "User submits question and receives structured regulatory answer"
    - "Query action orchestrates geocode -> embed -> retrieve -> generate -> parse"
    - "Query results are persisted to Convex for conversation history"
  artifacts:
    - path: "apps/convex/convex/actions/query.ts"
      provides: "Query pipeline orchestration action"
      exports: ["processQuery"]
    - path: "apps/convex/convex/mutations/saveQuery.ts"
      provides: "Query persistence mutations"
      exports: ["saveQueryResult"]
  key_links:
    - from: "apps/convex/convex/actions/query.ts"
      to: "lib/geocode.ts"
      via: "geocodeAddress call"
      pattern: "await geocodeAddress"
    - from: "apps/convex/convex/actions/query.ts"
      to: "lib/embed.ts"
      via: "embedQuery call"
      pattern: "await embedQuery"
    - from: "apps/convex/convex/actions/query.ts"
      to: "lib/retrieve.ts"
      via: "retrieveChunks call"
      pattern: "await retrieveChunks"
    - from: "apps/convex/convex/actions/query.ts"
      to: "lib/generate.ts"
      via: "generateAnswer call"
      pattern: "await generateAnswer"
---

<objective>
Create query orchestration action that ties together all pipeline components.

Purpose: Implements QUERY-01 (natural language questions) by orchestrating the full RAG pipeline: geocode address -> embed query -> retrieve chunks -> generate answer -> parse response -> persist result.

Output:
- Convex action that processes compliance queries end-to-end
- Mutation for persisting query results
- Schema updates for query tracking (if needed)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-query-pipeline/07-CONTEXT.md
@.planning/phases/07-query-pipeline/07-RESEARCH.md
@.planning/phases/07-query-pipeline/07-01-SUMMARY.md
@.planning/phases/07-query-pipeline/07-02-SUMMARY.md
@.planning/phases/07-query-pipeline/07-03-SUMMARY.md
@.planning/phases/07-query-pipeline/07-04-SUMMARY.md
@apps/convex/convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create query persistence mutation</name>
  <files>apps/convex/convex/mutations/saveQuery.ts</files>
  <action>
Create query persistence mutation in apps/convex/convex/mutations/saveQuery.ts:

1. **saveQueryResult mutation:**
   ```typescript
   import { mutation } from '../_generated/server';
   import { v } from 'convex/values';

   export const saveQueryResult = mutation({
     args: {
       conversationId: v.optional(v.id('conversations')),
       question: v.string(),
       address: v.optional(v.string()),
       jurisdictions: v.array(v.string()),
       answerContent: v.string(),
       citations: v.array(v.object({
         id: v.number(),
         citation: v.string(),
         text: v.string(),
         url: v.optional(v.string()),
         jurisdiction: v.string(),
         sourceType: v.union(
           v.literal('federal'),
           v.literal('state'),
           v.literal('county'),
           v.literal('municipal')
         )
       })),
       permits: v.array(v.object({
         name: v.string(),
         issuingAgency: v.string(),
         jurisdiction: v.string(),
         url: v.optional(v.string()),
         citation: v.string()
       })),
       confidence: v.object({
         level: v.union(v.literal('High'), v.literal('Medium'), v.literal('Low')),
         score: v.number(),
         reason: v.string()
       }),
       processingTimeMs: v.number()
     },
     handler: async (ctx, args) => {
       const now = Date.now();

       // Create or use existing conversation
       let conversationId = args.conversationId;
       if (!conversationId) {
         // Create new conversation with question as title
         const title = args.question.length > 50
           ? args.question.substring(0, 50) + '...'
           : args.question;
         conversationId = await ctx.db.insert('conversations', {
           userId: 'system', // Will be replaced with auth in Phase 8
           title,
           createdAt: now,
           updatedAt: now
         });
       }

       // Save user question as message
       await ctx.db.insert('messages', {
         conversationId,
         role: 'user',
         content: args.question,
         status: 'complete',
         createdAt: now,
         updatedAt: now
       });

       // Save assistant response as message
       // Note: We store simplified citations in the message format
       const messageCitations = args.citations.map(c => ({
         sourceId: '0'.repeat(32) as any, // Placeholder - we don't have source IDs yet
         sectionNumber: c.citation,
         title: c.text.substring(0, 100),
         url: c.url ?? '',
         relevanceScore: undefined
       }));

       const messageId = await ctx.db.insert('messages', {
         conversationId,
         role: 'assistant',
         content: args.answerContent,
         status: 'complete',
         citations: messageCitations.length > 0 ? messageCitations : undefined,
         createdAt: now,
         updatedAt: now
       });

       // Update conversation timestamp
       await ctx.db.patch(conversationId, { updatedAt: now });

       return { conversationId, messageId };
     }
   });
   ```

Note: The message citations format is constrained by the existing schema. We're adapting our richer Citation type to fit. In Phase 8, we may want to evolve the schema.
  </action>
  <verify>
```bash
cd apps/convex && npx tsc --noEmit
```
  </verify>
  <done>saveQueryResult persists question and answer to conversations/messages tables</done>
</task>

<task type="auto">
  <name>Task 2: Create query orchestration action</name>
  <files>apps/convex/convex/actions/query.ts</files>
  <action>
Create query orchestration action in apps/convex/convex/actions/query.ts:

1. **processQuery action:**
   ```typescript
   import { action } from '../_generated/server';
   import { v } from 'convex/values';
   import { internal } from '../_generated/api';

   import { geocodeAddress, getFallbackJurisdictions } from '../lib/geocode';
   import { embedQuery } from '../lib/embed';
   import { retrieveChunks } from '../lib/retrieve';
   import { calculateConfidence } from '../lib/confidence';
   import { buildSystemPrompt, buildUserPrompt } from '../lib/prompt';
   import { generateAnswer } from '../lib/generate';
   import { parseAnswer } from '../lib/parse';
   import type { QueryResult, GeneratedAnswer, RetrievedChunk } from '../query/types';

   export const processQuery = action({
     args: {
       question: v.string(),
       address: v.optional(v.string()),
       conversationId: v.optional(v.id('conversations'))
     },
     handler: async (ctx, args): Promise<QueryResult> => {
       const startTime = Date.now();

       // Get API keys from environment
       const geocodioKey = process.env.GEOCODIO_API_KEY;
       const openaiKey = process.env.OPENAI_API_KEY;
       const pineconeKey = process.env.PINECONE_API_KEY;
       const anthropicKey = process.env.ANTHROPIC_API_KEY;

       if (!openaiKey || !pineconeKey || !anthropicKey) {
         throw new Error('Missing required API keys (OPENAI_API_KEY, PINECONE_API_KEY, ANTHROPIC_API_KEY)');
       }

       // Step 1: Geocode address to jurisdictions
       let jurisdictionResult = getFallbackJurisdictions();
       if (args.address && geocodioKey) {
         try {
           jurisdictionResult = await geocodeAddress(args.address, geocodioKey);
         } catch (error) {
           console.warn('Geocoding failed, using federal-only fallback:', error);
         }
       }
       const { jurisdictions } = jurisdictionResult;

       // Step 2: Generate query embedding
       const queryEmbedding = await embedQuery(args.question, openaiKey);

       // Step 3: Retrieve relevant chunks from Pinecone
       const chunks = await retrieveChunks(
         queryEmbedding,
         jurisdictions,
         pineconeKey,
         { topK: 50, minScore: 0.5, rerank: true, finalTopK: 15 }
       );

       // Step 4: Calculate confidence based on retrieval
       const confidence = calculateConfidence(chunks, jurisdictions);

       // Step 5: Build prompts
       const systemPrompt = buildSystemPrompt();
       const userPrompt = buildUserPrompt(args.question, chunks, jurisdictions);

       // Step 6: Generate answer with Claude
       const rawAnswer = await generateAnswer(systemPrompt, userPrompt, anthropicKey);

       // Step 7: Parse answer into structured format
       const parsed = parseAnswer(rawAnswer, chunks);

       // Log any warnings
       if (parsed.warnings.length > 0) {
         console.warn('Answer parsing warnings:', parsed.warnings);
       }

       // Build GeneratedAnswer
       const answer: GeneratedAnswer = {
         summary: extractSummary(rawAnswer), // First paragraph or first 500 chars
         sections: parsed.sections,
         permits: parsed.permits,
         citations: parsed.citations,
         confidence
       };

       // Step 8: Persist to Convex
       const { conversationId, messageId } = await ctx.runMutation(
         internal.mutations.saveQuery.saveQueryResult,
         {
           conversationId: args.conversationId,
           question: args.question,
           address: args.address,
           jurisdictions,
           answerContent: rawAnswer,
           citations: parsed.citations,
           permits: parsed.permits,
           confidence: {
             level: confidence.level,
             score: confidence.score,
             reason: confidence.reason
           },
           processingTimeMs: Date.now() - startTime
         }
       );

       const processingTimeMs = Date.now() - startTime;

       return {
         queryId: messageId,
         question: args.question,
         address: args.address,
         jurisdictions,
         answer,
         retrievedChunks: chunks,
         processingTimeMs
       };
     }
   });

   // Helper: Extract summary from answer (first paragraph)
   function extractSummary(text: string): string {
     const firstParagraph = text.split('\n\n')[0] || text;
     if (firstParagraph.length <= 500) {
       return firstParagraph;
     }
     return firstParagraph.substring(0, 500) + '...';
   }
   ```

2. **Export the action** so it can be called from frontend.

Note: This action orchestrates all components. It's the main entry point for QUERY-01.
  </action>
  <verify>
```bash
cd apps/convex && npx tsc --noEmit
```
  </verify>
  <done>processQuery action orchestrates full RAG pipeline and returns QueryResult</done>
</task>

<task type="auto">
  <name>Task 3: Update internal exports</name>
  <files>apps/convex/convex/_generated/api.ts (auto), apps/convex/convex/mutations/saveQuery.ts</files>
  <action>
Ensure the saveQueryResult mutation is exported as internal (not public API):

1. In apps/convex/convex/mutations/saveQuery.ts, use `internalMutation` instead of `mutation`:
   ```typescript
   import { internalMutation } from '../_generated/server';
   ```

2. The action uses `internal.mutations.saveQuery.saveQueryResult` to call it.

3. Create an index file for query exports if helpful:
   - apps/convex/convex/query/index.ts (optional)

Run `npx convex dev` briefly to regenerate _generated files and verify exports work.
  </action>
  <verify>
```bash
cd apps/convex && npx tsc --noEmit
```
  </verify>
  <done>Internal mutation properly exported for action to call</done>
</task>

</tasks>

<verification>
1. apps/convex/convex/actions/query.ts exists with processQuery action
2. apps/convex/convex/mutations/saveQuery.ts exists with saveQueryResult internalMutation
3. TypeScript compiles: `cd apps/convex && npx tsc --noEmit`
4. Action imports all lib modules (geocode, embed, retrieve, confidence, prompt, generate, parse)
5. Action calls internal mutation to persist results
</verification>

<success_criteria>
- processQuery action accepts question + optional address + optional conversationId
- Action orchestrates: geocode -> embed -> retrieve -> calculate confidence -> build prompts -> generate -> parse -> persist
- Results saved to conversations and messages tables
- Returns QueryResult with answer, citations, permits, confidence
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-query-pipeline/07-05-SUMMARY.md`
</output>
