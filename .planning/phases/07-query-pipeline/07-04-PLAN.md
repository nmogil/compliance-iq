---
phase: 07-query-pipeline
plan: 04
type: execute
wave: 2
depends_on: ["07-01", "07-02"]
files_modified:
  - apps/convex/convex/lib/generate.ts
  - apps/convex/convex/lib/parse.ts
  - apps/convex/package.json
autonomous: true

must_haves:
  truths:
    - "Claude generates answer with inline citations [N]"
    - "Response is parsed into structured JurisdictionSection array"
    - "Permits are extracted into dedicated array"
  artifacts:
    - path: "apps/convex/convex/lib/generate.ts"
      provides: "Claude API integration for answer generation"
      exports: ["generateAnswer", "GenerationError"]
    - path: "apps/convex/convex/lib/parse.ts"
      provides: "Response parsing for citations and permits"
      exports: ["parseAnswer", "extractCitations", "extractPermits", "validateCitations"]
  key_links:
    - from: "apps/convex/convex/lib/generate.ts"
      to: "Anthropic API"
      via: "claude-sonnet-4-5 model"
      pattern: "client.messages.create"
    - from: "apps/convex/convex/lib/parse.ts"
      to: "RetrievedChunk array"
      via: "citation validation"
      pattern: "\\[\\d+\\]"
---

<objective>
Create Claude answer generation and response parsing modules.

Purpose: Generates cited compliance answers using Claude API (QUERY-04, QUERY-06) and parses responses into structured format with validated citations. Extracted permits satisfy QUERY-07.

Output:
- Claude API integration for non-streaming answer generation
- Response parser extracting citations, permits, and jurisdiction sections
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-query-pipeline/07-CONTEXT.md
@.planning/phases/07-query-pipeline/07-RESEARCH.md
@.planning/phases/07-query-pipeline/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude answer generation module</name>
  <files>apps/convex/convex/lib/generate.ts, apps/convex/package.json</files>
  <action>
Add Anthropic SDK to Convex app:
```bash
cd apps/convex && pnpm add @anthropic-ai/sdk
```

Create answer generation module in apps/convex/convex/lib/generate.ts:

1. **GenerationError class:**
   ```typescript
   export class GenerationError extends Error {
     constructor(
       message: string,
       public readonly code: 'API_ERROR' | 'CONTENT_FILTER' | 'RATE_LIMIT' | 'TIMEOUT',
       public readonly cause?: unknown
     ) {
       super(message);
       this.name = 'GenerationError';
     }
   }
   ```

2. **Constants:**
   - MODEL = 'claude-sonnet-4-5'
   - MAX_TOKENS = 4096
   - TEMPERATURE = 0 (for factual accuracy)

3. **generateAnswer function:**
   ```typescript
   export async function generateAnswer(
     systemPrompt: string,
     userPrompt: string,
     apiKey: string
   ): Promise<string>
   ```

   Implementation:
   ```typescript
   import Anthropic from '@anthropic-ai/sdk';

   const client = new Anthropic({ apiKey });

   try {
     const response = await client.messages.create({
       model: MODEL,
       max_tokens: MAX_TOKENS,
       temperature: 0,
       system: systemPrompt,
       messages: [{ role: 'user', content: userPrompt }],
     });

     // Extract text from response
     const textBlock = response.content.find(block => block.type === 'text');
     if (!textBlock || textBlock.type !== 'text') {
       throw new GenerationError('No text in response', 'API_ERROR');
     }

     return textBlock.text;
   } catch (error) {
     // Handle specific error types
     if (error instanceof GenerationError) throw error;

     const err = error as any;
     if (err?.status === 429) {
       throw new GenerationError('Rate limit exceeded', 'RATE_LIMIT', error);
     }
     if (err?.status === 400 && err?.error?.type === 'invalid_request_error') {
       throw new GenerationError('Content filter triggered', 'CONTENT_FILTER', error);
     }

     throw new GenerationError('Failed to generate answer', 'API_ERROR', error);
   }
   ```

Note: This is NON-STREAMING. Streaming is Phase 9 (QUERY-05). This plan focuses on getting correct answers with citations first.
  </action>
  <verify>
```bash
cd apps/convex && npx tsc --noEmit
```
  </verify>
  <done>generateAnswer calls Claude API and returns text response</done>
</task>

<task type="auto">
  <name>Task 2: Create response parsing module</name>
  <files>apps/convex/convex/lib/parse.ts</files>
  <action>
Create response parsing module in apps/convex/convex/lib/parse.ts:

1. **extractCitations function:**
   ```typescript
   export function extractCitations(
     text: string,
     chunks: RetrievedChunk[]
   ): Citation[]
   ```

   Implementation:
   - Find all [N] references in text using regex: /\[(\d+)\]/g
   - Map each unique N to corresponding chunk (chunks[N-1])
   - Build Citation object:
     ```typescript
     {
       id: N,
       citation: chunk.citation,
       text: chunk.text.substring(0, 200) + '...', // First 200 chars
       url: chunk.url,
       jurisdiction: chunk.jurisdiction,
       sourceType: chunk.sourceType
     }
     ```
   - Return unique citations (dedupe by id)

2. **validateCitations function:**
   ```typescript
   export function validateCitations(
     text: string,
     chunks: RetrievedChunk[]
   ): { valid: boolean; invalidRefs: number[] }
   ```

   Implementation:
   - Find all [N] references in text
   - Check if each N corresponds to a chunk (N <= chunks.length)
   - Return list of invalid references (citations to non-existent chunks)
   - If any invalid, log warning but don't fail

3. **extractPermits function:**
   ```typescript
   export function extractPermits(text: string): Permit[]
   ```

   Implementation:
   - Find "Required Permits and Licenses" or "### Required Permits" section
   - Parse permit entries using pattern matching:
     - **Permit Name**: capture name
     - **Issuing Agency**: capture agency
     - **Jurisdiction**: capture jurisdiction
     - **Link**: capture URL (optional)
     - **Regulatory Reference**: capture citation
   - Use regex or simple string parsing to extract structured data
   - Return array of Permit objects

4. **parseJurisdictionSections function:**
   ```typescript
   export function parseJurisdictionSections(text: string): JurisdictionSection[]
   ```

   Implementation:
   - Split by ### headers (Federal, State, County, Municipal)
   - For each section:
     - Extract level from header
     - Extract content between headers
     - Identify citations [N] within section content
   - Return array of JurisdictionSection objects (without citations/permits populated - those come from extractCitations)

5. **parseAnswer function (main orchestrator):**
   ```typescript
   export function parseAnswer(
     rawAnswer: string,
     chunks: RetrievedChunk[]
   ): { sections: JurisdictionSection[]; citations: Citation[]; permits: Permit[]; warnings: string[] }
   ```

   Implementation:
   - Call validateCitations - collect warnings for invalid refs
   - Call extractCitations - build citation array
   - Call extractPermits - build permits array
   - Call parseJurisdictionSections - build sections
   - Return combined result with warnings

Import types from "../query/types".
  </action>
  <verify>
```bash
cd apps/convex && npx tsc --noEmit
```
  </verify>
  <done>parseAnswer extracts citations, permits, and jurisdiction sections from Claude response</done>
</task>

</tasks>

<verification>
1. apps/convex/convex/lib/generate.ts exists with generateAnswer, GenerationError
2. apps/convex/convex/lib/parse.ts exists with extractCitations, extractPermits, parseJurisdictionSections, parseAnswer, validateCitations
3. package.json includes @anthropic-ai/sdk
4. TypeScript compiles: `cd apps/convex && npx tsc --noEmit`
5. Citation validation catches invalid [N] references
</verification>

<success_criteria>
- generateAnswer calls Claude API with system/user prompts and returns text
- extractCitations maps [N] references to source chunks
- validateCitations identifies citations to non-existent chunks
- extractPermits parses structured permit data from response
- parseAnswer combines all parsers into single output
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-query-pipeline/07-04-SUMMARY.md`
</output>
