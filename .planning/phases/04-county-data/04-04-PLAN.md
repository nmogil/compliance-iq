---
phase: 04-county-data
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - apps/workers/src/counties/chunk.ts
  - apps/workers/src/counties/fetch.ts
autonomous: true

must_haves:
  truths:
    - "County ordinances chunked at section level with proper overlap"
    - "Fetch orchestrator uses adapters to fetch from all enabled counties"
    - "Rate limiting applied consistently across all adapters"
  artifacts:
    - path: "apps/workers/src/counties/chunk.ts"
      provides: "County ordinance chunking with token limits"
      exports: ["chunkCountyOrdinance", "chunkCounty", "getCountyChunkStats"]
    - path: "apps/workers/src/counties/fetch.ts"
      provides: "Fetch orchestrator using adapters"
      exports: ["fetchCountyOrdinances", "fetchAllEnabledCounties"]
  key_links:
    - from: "apps/workers/src/counties/chunk.ts"
      to: "apps/workers/src/lib/tokens.ts"
      via: "Token counting imports"
      pattern: "import.*from.*lib/tokens"
    - from: "apps/workers/src/counties/fetch.ts"
      to: "apps/workers/src/counties/adapters/index.ts"
      via: "Adapter factory usage"
      pattern: "getAdapterForCounty|getAdaptersForEnabledCounties"
---

<objective>
Create county ordinance chunking module and fetch orchestrator.

Purpose: Transform raw ordinance HTML into embeddable chunks and provide a unified interface for fetching ordinances from all enabled counties using the adapter infrastructure.

Output:
- County chunking module following texas/chunk.ts patterns
- Fetch orchestrator that uses adapters for each county platform
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-county-data/04-RESEARCH.md
@.planning/phases/04-county-data/04-02-SUMMARY.md
@.planning/phases/04-county-data/04-03-SUMMARY.md
@apps/workers/src/texas/chunk.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create county chunking module</name>
  <files>apps/workers/src/counties/chunk.ts</files>
  <action>
Create chunking module for county ordinances following texas/chunk.ts patterns.

Key parameters (from existing decisions):
- Token limit: 1500 (same as federal/state)
- Overlap: 15%
- Split method: paragraph-based for long sections

```typescript
import { countTokens } from '../lib/tokens';
import { generateCountyCitation } from '../lib/citations';
import type { CountyOrdinance, CountyChunk, CountySourceConfig } from './types';
import { getCountyByName } from './sources';

/** Maximum tokens per chunk */
const MAX_TOKENS = 1500;

/** Overlap percentage for split chunks */
const OVERLAP_PERCENT = 0.15;

/**
 * Chunk context for a county
 */
export interface CountyChunkContext {
  county: string;
  fipsCode: string;
  codeName: string;
  categories: string[];
}

/**
 * Chunk a single county ordinance section
 *
 * @param ordinance County ordinance to chunk
 * @param context County context for metadata
 * @returns Array of chunks for this ordinance
 */
export function chunkCountyOrdinance(
  ordinance: CountyOrdinance,
  context: CountyChunkContext
): CountyChunk[] {
  const baseId = `county-${ordinance.fipsCode}-${ordinance.chapter}-${ordinance.section}`;

  const fullText = ordinance.text;
  const tokenCount = countTokens(fullText);

  // If section fits in one chunk, return single chunk
  if (tokenCount <= MAX_TOKENS) {
    return [
      createChunk(ordinance, context, fullText, 0, 1, baseId)
    ];
  }

  // Split long sections with overlap
  const chunks = splitWithOverlap(fullText, MAX_TOKENS, OVERLAP_PERCENT);

  return chunks.map((text, index) =>
    createChunk(ordinance, context, text, index, chunks.length, baseId)
  );
}

/**
 * Create a CountyChunk from ordinance and text
 */
function createChunk(
  ordinance: CountyOrdinance,
  context: CountyChunkContext,
  text: string,
  index: number,
  total: number,
  baseId: string
): CountyChunk {
  const citation = generateCountyCitation(
    ordinance.county,
    context.codeName,
    ordinance.section
  );

  return {
    chunkId: `${baseId}-${index}`,
    sourceId: `county-${ordinance.fipsCode}`,
    sourceType: 'county',
    text,
    citation,
    url: ordinance.sourceUrl,
    county: ordinance.county,
    fipsCode: ordinance.fipsCode,
    chapter: ordinance.chapter,
    section: ordinance.section,
    chunkIndex: index,
    totalChunks: total,
    category: context.categories[0] // Primary category
  };
}

/**
 * Split text with overlap for context preservation
 */
function splitWithOverlap(
  text: string,
  maxTokens: number,
  overlapPercent: number
): string[] {
  const paragraphs = text.split(/\n\n+/);
  const chunks: string[] = [];
  let currentChunk = '';
  let currentTokens = 0;

  for (const paragraph of paragraphs) {
    const paragraphTokens = countTokens(paragraph);

    // If single paragraph exceeds max, split by sentences
    if (paragraphTokens > maxTokens) {
      if (currentChunk) {
        chunks.push(currentChunk.trim());
        currentChunk = '';
        currentTokens = 0;
      }

      const sentences = paragraph.split(/(?<=[.!?])\s+/);
      for (const sentence of sentences) {
        const sentenceTokens = countTokens(sentence);
        if (currentTokens + sentenceTokens > maxTokens && currentChunk) {
          chunks.push(currentChunk.trim());
          // Add overlap from end of previous chunk
          const overlapTokens = Math.floor(maxTokens * overlapPercent);
          currentChunk = getOverlapText(currentChunk, overlapTokens);
          currentTokens = countTokens(currentChunk);
        }
        currentChunk += (currentChunk ? ' ' : '') + sentence;
        currentTokens += sentenceTokens;
      }
    } else if (currentTokens + paragraphTokens > maxTokens) {
      // Start new chunk with overlap
      chunks.push(currentChunk.trim());
      const overlapTokens = Math.floor(maxTokens * overlapPercent);
      currentChunk = getOverlapText(currentChunk, overlapTokens) + '\n\n' + paragraph;
      currentTokens = countTokens(currentChunk);
    } else {
      currentChunk += (currentChunk ? '\n\n' : '') + paragraph;
      currentTokens += paragraphTokens;
    }
  }

  if (currentChunk.trim()) {
    chunks.push(currentChunk.trim());
  }

  return chunks;
}

/**
 * Get last N tokens worth of text for overlap
 */
function getOverlapText(text: string, targetTokens: number): string {
  const words = text.split(/\s+/);
  let result = '';
  let tokens = 0;

  // Work backwards from end
  for (let i = words.length - 1; i >= 0 && tokens < targetTokens; i--) {
    const wordTokens = countTokens(words[i]);
    result = words[i] + (result ? ' ' + result : '');
    tokens += wordTokens;
  }

  return result;
}

/**
 * Chunk all ordinances from a county
 *
 * @param ordinances Array of ordinances
 * @param countyName County name for context lookup
 * @returns Array of all chunks
 */
export function chunkCounty(
  ordinances: CountyOrdinance[],
  countyName: string
): CountyChunk[] {
  const config = getCountyByName(countyName);

  if (!config) {
    throw new Error(`County not found: ${countyName}`);
  }

  const context: CountyChunkContext = {
    county: config.name,
    fipsCode: config.fipsCode,
    codeName: 'County Code', // Default name, could be customized per county
    categories: config.categories
  };

  const chunks: CountyChunk[] = [];

  for (const ordinance of ordinances) {
    const sectionChunks = chunkCountyOrdinance(ordinance, context);
    chunks.push(...sectionChunks);
  }

  return chunks;
}

/**
 * Get chunking statistics for monitoring
 */
export function getCountyChunkStats(chunks: CountyChunk[]): {
  totalChunks: number;
  avgTokens: number;
  maxTokens: number;
  minTokens: number;
  countiesCovered: string[];
} {
  if (chunks.length === 0) {
    return {
      totalChunks: 0,
      avgTokens: 0,
      maxTokens: 0,
      minTokens: 0,
      countiesCovered: []
    };
  }

  const tokenCounts = chunks.map(c => countTokens(c.text));
  const counties = [...new Set(chunks.map(c => c.county))];

  return {
    totalChunks: chunks.length,
    avgTokens: Math.round(tokenCounts.reduce((a, b) => a + b, 0) / tokenCounts.length),
    maxTokens: Math.max(...tokenCounts),
    minTokens: Math.min(...tokenCounts),
    countiesCovered: counties
  };
}
```
  </action>
  <verify>TypeScript compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`</verify>
  <done>chunkCountyOrdinance and chunkCounty functions exported with 1500 token limit</done>
</task>

<task type="auto">
  <name>Task 2: Create fetch orchestrator</name>
  <files>apps/workers/src/counties/fetch.ts</files>
  <action>
Create fetch orchestrator that uses adapters to fetch ordinances from counties.

```typescript
import { getAdapterForCounty, getAdaptersForEnabledCounties } from './adapters';
import { storeCountyOrdinance } from './storage';
import type { CountyOrdinance, CountyAdapter } from './types';

/**
 * Fetch result for a single county
 */
export interface CountyFetchResult {
  county: string;
  fipsCode: string;
  success: boolean;
  ordinancesCount: number;
  error?: string;
  durationMs: number;
}

/**
 * Fetch all ordinances from a single county
 *
 * @param countyName County name (e.g., "Harris")
 * @param bucket R2 bucket for storage
 * @returns Fetch result with statistics
 */
export async function fetchCountyOrdinances(
  countyName: string,
  bucket: R2Bucket
): Promise<{
  result: CountyFetchResult;
  ordinances: CountyOrdinance[];
}> {
  const startTime = Date.now();
  const ordinances: CountyOrdinance[] = [];

  const adapter = getAdapterForCounty(countyName);

  if (!adapter) {
    return {
      result: {
        county: countyName,
        fipsCode: '',
        success: false,
        ordinancesCount: 0,
        error: `No adapter available for county: ${countyName}`,
        durationMs: Date.now() - startTime
      },
      ordinances: []
    };
  }

  console.log(`[FetchOrchestrator] Starting fetch for ${countyName} County`);

  try {
    // Validate source first
    const validation = await adapter.validateSource();
    if (!validation.accessible) {
      return {
        result: {
          county: adapter.county,
          fipsCode: adapter.fipsCode,
          success: false,
          ordinancesCount: 0,
          error: `Source validation failed: ${validation.error}`,
          durationMs: Date.now() - startTime
        },
        ordinances: []
      };
    }

    // Fetch ordinances
    for await (const ordinance of adapter.fetchOrdinances()) {
      ordinances.push(ordinance);

      // Store to R2
      const html = `<html><body>${ordinance.text}</body></html>`;
      await storeCountyOrdinance(bucket, ordinance, html);

      console.log(
        `[FetchOrchestrator] Stored: ${adapter.county} Chapter ${ordinance.chapter} Section ${ordinance.section}`
      );
    }

    console.log(
      `[FetchOrchestrator] Completed ${countyName}: ${ordinances.length} ordinances`
    );

    return {
      result: {
        county: adapter.county,
        fipsCode: adapter.fipsCode,
        success: true,
        ordinancesCount: ordinances.length,
        durationMs: Date.now() - startTime
      },
      ordinances
    };
  } catch (error) {
    console.error(`[FetchOrchestrator] Error fetching ${countyName}:`, error);

    return {
      result: {
        county: adapter.county,
        fipsCode: adapter.fipsCode,
        success: false,
        ordinancesCount: ordinances.length,
        error: error instanceof Error ? error.message : 'Unknown error',
        durationMs: Date.now() - startTime
      },
      ordinances
    };
  }
}

/**
 * Fetch ordinances from all enabled counties
 *
 * @param bucket R2 bucket for storage
 * @returns Results for each county
 */
export async function fetchAllEnabledCounties(
  bucket: R2Bucket
): Promise<{
  results: CountyFetchResult[];
  totalOrdinances: number;
  successCount: number;
  failCount: number;
}> {
  const adapters = getAdaptersForEnabledCounties();
  const results: CountyFetchResult[] = [];
  let totalOrdinances = 0;

  console.log(`[FetchOrchestrator] Starting fetch for ${adapters.length} counties`);

  for (const adapter of adapters) {
    const { result, ordinances } = await fetchCountyOrdinances(
      adapter.county,
      bucket
    );

    results.push(result);
    totalOrdinances += ordinances.length;
  }

  const successCount = results.filter(r => r.success).length;
  const failCount = results.filter(r => !r.success).length;

  console.log(
    `[FetchOrchestrator] Completed: ${successCount} success, ${failCount} failed, ${totalOrdinances} total ordinances`
  );

  return {
    results,
    totalOrdinances,
    successCount,
    failCount
  };
}

/**
 * Validate all enabled county sources
 *
 * @returns Validation results
 */
export async function validateCountySources(): Promise<{
  valid: string[];
  invalid: Array<{ county: string; error: string }>;
}> {
  const adapters = getAdaptersForEnabledCounties();
  const valid: string[] = [];
  const invalid: Array<{ county: string; error: string }> = [];

  for (const adapter of adapters) {
    console.log(`[Validation] Checking ${adapter.county} County...`);

    const result = await adapter.validateSource();

    if (result.accessible) {
      valid.push(adapter.county);
      console.log(`[Validation] ${adapter.county}: OK`);
    } else {
      invalid.push({ county: adapter.county, error: result.error || 'Unknown error' });
      console.log(`[Validation] ${adapter.county}: FAILED - ${result.error}`);
    }

    // Rate limit between validations
    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  return { valid, invalid };
}
```
  </action>
  <verify>TypeScript compiles and exports are available</verify>
  <done>fetchCountyOrdinances and fetchAllEnabledCounties exported with R2 storage integration</done>
</task>

</tasks>

<verification>
1. Chunking module uses 1500 token limit with 15% overlap
2. Fetch orchestrator uses adapters for each county
3. R2 storage integrated for both fetch and chunk operations
4. All code compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`
</verification>

<success_criteria>
- chunkCountyOrdinance handles sections under/over token limit
- splitWithOverlap implements 15% overlap for long sections
- fetchCountyOrdinances returns ordinances and stores to R2
- fetchAllEnabledCounties processes all enabled counties sequentially
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-county-data/04-04-SUMMARY.md`
</output>
