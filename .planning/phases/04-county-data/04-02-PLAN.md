---
phase: 04-county-data
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/workers/src/counties/adapters/base.ts
  - apps/workers/src/counties/adapters/municode.ts
  - apps/workers/src/counties/storage.ts
autonomous: true

must_haves:
  truths:
    - "Base adapter interface defines consistent scraping contract"
    - "MunicipalCodeOnline adapter can fetch Harris County ordinances"
    - "County ordinances stored in R2 with correct folder structure"
    - "County checkpoint management enables pipeline resumption"
  artifacts:
    - path: "apps/workers/src/counties/adapters/base.ts"
      provides: "Abstract CountyAdapter base class"
      exports: ["CountyAdapterBase", "loadCheerioPage"]
    - path: "apps/workers/src/counties/adapters/municode.ts"
      provides: "MunicipalCodeOnline scraper for Harris County"
      exports: ["MunicodeAdapter"]
    - path: "apps/workers/src/counties/storage.ts"
      provides: "R2 storage for county ordinances and checkpoints"
      exports: ["storeCountyOrdinance", "getCountyOrdinance", "saveCountyCheckpoint", "loadCountyCheckpoint", "clearCountyCheckpoint"]
  key_links:
    - from: "apps/workers/src/counties/adapters/municode.ts"
      to: "apps/workers/src/counties/adapters/base.ts"
      via: "extends CountyAdapterBase"
      pattern: "extends CountyAdapterBase"
    - from: "apps/workers/src/counties/storage.ts"
      to: "apps/workers/src/lib/r2.ts"
      via: "r2 storage imports"
      pattern: "import.*from.*lib/r2"
---

<objective>
Create the adapter infrastructure and first platform adapter for county ordinance scraping.

Purpose: Establish the adapter pattern that allows heterogeneous county platforms to be scraped with a consistent interface, starting with MunicipalCodeOnline (Harris County).

Output:
- Abstract base adapter with common scraping utilities
- MunicipalCodeOnline adapter for Harris County
- R2 storage module for county ordinances and checkpoints
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-county-data/04-RESEARCH.md
@.planning/phases/04-county-data/04-01-SUMMARY.md
@apps/workers/src/texas/storage.ts
@apps/workers/src/lib/scraper.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base adapter class</name>
  <files>apps/workers/src/counties/adapters/base.ts</files>
  <action>
Create abstract base class implementing common scraping utilities for all county adapters.

```typescript
import * as cheerio from 'cheerio';
import { retryWithBackoff, fetchWithRateLimit } from '../../lib/scraper';
import type { CountyAdapter, CountyOrdinance, CountySourceConfig } from '../types';

/**
 * Abstract base class for county ordinance adapters
 *
 * Provides common utilities for:
 * - Rate-limited HTTP fetching
 * - Cheerio HTML parsing
 * - Source validation
 * - Error handling
 */
export abstract class CountyAdapterBase implements CountyAdapter {
  abstract county: string;
  abstract fipsCode: string;
  abstract baseUrl: string;
  abstract platform: CountySourceConfig['platform'];

  /** Rate limit delay between requests (ms) */
  protected rateLimit = 500;

  /** User-Agent header for requests */
  protected userAgent = 'ComplianceIQ/1.0 (+https://compliance-iq.com)';

  abstract fetchOrdinances(): AsyncGenerator<CountyOrdinance, void, unknown>;

  async validateSource(): Promise<{ accessible: boolean; error?: string }> {
    try {
      const response = await fetch(this.baseUrl, {
        headers: { 'User-Agent': this.userAgent }
      });

      if (!response.ok) {
        return { accessible: false, error: `HTTP ${response.status}` };
      }

      const html = await response.text();
      const $ = cheerio.load(html);

      const isValid = this.validateStructure($);
      if (!isValid) {
        return {
          accessible: false,
          error: 'HTML structure changed - expected elements not found'
        };
      }

      return { accessible: true };
    } catch (error) {
      return {
        accessible: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Validate expected HTML structure exists
   * Override in subclasses for platform-specific validation
   */
  protected abstract validateStructure($: cheerio.CheerioAPI): boolean;

  /**
   * Load and parse HTML page with Cheerio
   */
  protected async loadPage(url: string): Promise<cheerio.CheerioAPI> {
    const html = await retryWithBackoff(
      async () => {
        const response = await fetchWithRateLimit(url, this.rateLimit, {
          headers: { 'User-Agent': this.userAgent }
        });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.text();
      },
      `loadPage(${url})`
    );
    return cheerio.load(html);
  }

  /**
   * Sleep for rate limiting
   */
  protected async sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

/**
 * Helper: Load Cheerio page with retry logic
 * Exported for use in individual adapters
 */
export async function loadCheerioPage(
  url: string,
  rateLimit = 500,
  userAgent = 'ComplianceIQ/1.0'
): Promise<cheerio.CheerioAPI> {
  const html = await retryWithBackoff(
    async () => {
      const response = await fetchWithRateLimit(url, rateLimit, {
        headers: { 'User-Agent': userAgent }
      });
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      return response.text();
    },
    `loadCheerioPage(${url})`
  );
  return cheerio.load(html);
}
```

Note: If `fetchWithRateLimit` doesn't exist in lib/scraper.ts, use `fetch` directly with a manual delay before each request.
  </action>
  <verify>TypeScript compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`</verify>
  <done>CountyAdapterBase class exported with loadPage, validateSource, sleep utilities</done>
</task>

<task type="auto">
  <name>Task 2: Create MunicipalCodeOnline adapter</name>
  <files>apps/workers/src/counties/adapters/municode.ts</files>
  <action>
Create adapter for MunicipalCodeOnline.com platform (used by Harris County).

First, inspect https://harriscounty.municipalcodeonline.com/ to understand the HTML structure:
- Look for ordinance chapter/section listing
- Identify CSS selectors for navigation and content
- Check for pagination or infinite scroll

Implement adapter:

```typescript
import * as cheerio from 'cheerio';
import { CountyAdapterBase } from './base';
import type { CountyOrdinance, CountySourceConfig } from '../types';

/**
 * MunicipalCodeOnline.com adapter
 *
 * Used by Harris County and potentially other Texas counties.
 * Platform URL pattern: https://{county}.municipalcodeonline.com/
 */
export class MunicodeAdapter extends CountyAdapterBase {
  county: string;
  fipsCode: string;
  baseUrl: string;
  platform: CountySourceConfig['platform'] = 'municode-online';

  constructor(config: { county: string; fipsCode: string; baseUrl: string }) {
    super();
    this.county = config.county;
    this.fipsCode = config.fipsCode;
    this.baseUrl = config.baseUrl;
  }

  protected validateStructure($: cheerio.CheerioAPI): boolean {
    // Validate MunicipalCodeOnline structure exists
    // Adjust selectors based on actual HTML inspection
    return (
      $('.ordinance-section').length > 0 ||
      $('.code-chapter').length > 0 ||
      $('[data-type="ordinance"]').length > 0 ||
      // Fallback: any reasonable content indicator
      $('main').length > 0
    );
  }

  async *fetchOrdinances(): AsyncGenerator<CountyOrdinance, void, unknown> {
    console.log(`[MunicodeAdapter] Starting fetch for ${this.county} County`);

    const $ = await this.loadPage(this.baseUrl);

    // Extract chapter links from main page
    // NOTE: Selectors need adjustment based on actual HTML structure
    const chapterLinks = this.extractChapterLinks($);

    for (const link of chapterLinks) {
      console.log(`[MunicodeAdapter] Processing chapter: ${link.title}`);

      await this.sleep(this.rateLimit);

      const chapter$ = await this.loadPage(link.url);
      const sections = this.extractSections(chapter$, link);

      for (const section of sections) {
        yield section;
      }
    }
  }

  private extractChapterLinks($: cheerio.CheerioAPI): Array<{ url: string; title: string; chapter: string }> {
    const links: Array<{ url: string; title: string; chapter: string }> = [];

    // Try multiple selector strategies for robustness
    const selectors = [
      '.chapter-link a',
      '.toc-chapter a',
      'nav a[href*="chapter"]',
      '.code-nav a'
    ];

    for (const selector of selectors) {
      $(selector).each((_, el) => {
        const href = $(el).attr('href');
        const title = $(el).text().trim();

        if (href && title) {
          const url = href.startsWith('http') ? href : `${this.baseUrl}${href}`;
          const chapterMatch = title.match(/Chapter\s+(\d+)/i);
          const chapter = chapterMatch ? chapterMatch[1] : '0';

          links.push({ url, title, chapter });
        }
      });

      if (links.length > 0) break;
    }

    return links;
  }

  private extractSections(
    $: cheerio.CheerioAPI,
    chapter: { chapter: string }
  ): CountyOrdinance[] {
    const sections: CountyOrdinance[] = [];

    // Try multiple selector strategies
    const sectionSelectors = [
      '.ordinance-section',
      '.code-section',
      'section[data-type="section"]',
      '.section-content'
    ];

    for (const selector of sectionSelectors) {
      $(selector).each((_, el) => {
        const heading = $(el).find('h1, h2, h3, .section-heading').first().text().trim();
        const text = $(el).find('.section-text, .section-body, p').text().trim();
        const sectionMatch = heading.match(/(?:Section|Sec\.?)\s*([\d.]+)/i);

        if (heading && text) {
          sections.push({
            county: this.county,
            fipsCode: this.fipsCode,
            chapter: chapter.chapter,
            section: sectionMatch ? sectionMatch[1] : '0',
            heading,
            text,
            sourceUrl: this.baseUrl,
            scrapedAt: new Date().toISOString()
          });
        }
      });

      if (sections.length > 0) break;
    }

    return sections;
  }
}
```

The actual selectors will need refinement during implementation based on the live HTML structure of harriscounty.municipalcodeonline.com.
  </action>
  <verify>TypeScript compiles and adapter is exported</verify>
  <done>MunicodeAdapter class implements fetchOrdinances AsyncGenerator with rate limiting</done>
</task>

<task type="auto">
  <name>Task 3: Create county storage module</name>
  <files>apps/workers/src/counties/storage.ts</files>
  <action>
Create R2 storage module for county ordinances following texas/storage.ts patterns.

Folder structure:
```
counties/
  ├── {county-fips}/           # e.g., 48201 for Harris
  │   ├── chapter-{N}/
  │   │   └── {section}.html
  │   └── ...
  └── checkpoints/
      └── county.json
```

Implement:

1. **storeCountyOrdinance(bucket, ordinance, html)** - Store ordinance HTML
   - Key: `counties/{fipsCode}/chapter-{chapter}/{section}.html`
   - Metadata: source platform, county name, chapter, section, fetchedAt

2. **getCountyOrdinance(bucket, fipsCode, chapter, section)** - Retrieve ordinance
   - Return HTML content or null

3. **listCountyOrdinances(bucket, fipsCode, chapter?)** - List stored sections
   - Return array of section identifiers

4. **saveCountyCheckpoint(bucket, checkpoint)** - Save pipeline checkpoint
   - Key: `counties/checkpoints/county.json`

5. **loadCountyCheckpoint(bucket)** - Load checkpoint
   - Return checkpoint or null if fresh start

6. **clearCountyCheckpoint(bucket)** - Clear after completion

Follow texas/storage.ts patterns for storeDocument/getDocument/listDocuments usage.
  </action>
  <verify>TypeScript compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`</verify>
  <done>All 6 storage functions exported and compile</done>
</task>

</tasks>

<verification>
1. Base adapter provides common utilities for all platform adapters
2. MunicodeAdapter extends base and implements fetchOrdinances generator
3. Storage module handles R2 operations with correct folder structure
4. All code compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`
</verification>

<success_criteria>
- CountyAdapterBase abstract class exported with loadPage, validateSource utilities
- MunicodeAdapter implements fetchOrdinances as AsyncGenerator
- Storage functions follow texas/storage.ts patterns
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-county-data/04-02-SUMMARY.md`
</output>
