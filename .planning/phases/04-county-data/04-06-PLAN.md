---
phase: 04-county-data
plan: 06
type: execute
wave: 5
depends_on: ["04-05"]
files_modified:
  - apps/workers/src/index.ts
  - apps/convex/convex/schema.ts
  - apps/convex/convex/jurisdictions.ts
  - apps/workers/src/counties/coverage.ts
  - scripts/test-county-query.ts
autonomous: true

must_haves:
  truths:
    - "HTTP endpoints available for triggering county pipeline"
    - "Convex jurisdictions table lists all 10 counties with coverage status"
    - "Coverage report documents processed vs skipped counties"
    - "Test queries filtered by county return relevant local regulations"
  artifacts:
    - path: "apps/workers/src/index.ts"
      provides: "County HTTP endpoints"
      contains: "/pipeline/counties"
    - path: "apps/convex/convex/jurisdictions.ts"
      provides: "Convex jurisdictions table operations for counties"
      contains: "tx-county"
    - path: "apps/convex/convex/schema.ts"
      provides: "Jurisdictions table with status field and county index"
      contains: "by_county_fips"
    - path: "scripts/test-county-query.ts"
      provides: "County jurisdiction query filter test"
      contains: "TX-48201"
  key_links:
    - from: "apps/workers/src/index.ts"
      to: "apps/workers/src/counties/index.ts"
      via: "County pipeline imports"
      pattern: "import.*from.*counties"
    - from: "scripts/test-county-query.ts"
      to: "Pinecone index"
      via: "Query with jurisdiction filter"
      pattern: "jurisdiction.*TX-48201"
---

<objective>
Add HTTP endpoints for the county pipeline and update Convex jurisdictions table.

Purpose: Enable manual triggering of county pipeline and provide coverage tracking in the application database.

Output:
- HTTP endpoints for county pipeline (batch and single-county)
- Convex jurisdictions table with county coverage status
- Documentation of processed vs skipped counties
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-county-data/04-RESEARCH.md
@.planning/phases/04-county-data/04-05-SUMMARY.md
@apps/workers/src/index.ts
@apps/convex/convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add county HTTP endpoints</name>
  <files>apps/workers/src/index.ts</files>
  <action>
Add HTTP endpoints for county pipeline following the existing federal/texas patterns.

New endpoints to add:
1. `POST /pipeline/counties` - Process all enabled counties
2. `POST /pipeline/counties/:county` - Process single county (e.g., `/pipeline/counties/harris`)
3. `GET /pipeline/counties/status` - Get county source status (enabled/disabled)
4. `POST /pipeline/counties/validate` - Validate all county sources

Add to the existing worker router:

```typescript
import {
  processAllCounties,
  processCounty,
  getEnabledCounties,
  getSkippedCounties,
  validateCountySources
} from './counties';

// In the fetch handler, add routes:

// POST /pipeline/counties - Process all enabled counties
if (request.method === 'POST' && pathname === '/pipeline/counties') {
  console.log('[Worker] Starting county pipeline (all counties)');

  const result = await processAllCounties(env.BUCKET, {
    OPENAI_API_KEY: env.OPENAI_API_KEY,
    PINECONE_API_KEY: env.PINECONE_API_KEY,
    CONVEX_URL: env.CONVEX_URL
  });

  return new Response(JSON.stringify(result, null, 2), {
    status: result.success ? 200 : 207, // 207 Multi-Status if partial success
    headers: { 'Content-Type': 'application/json' }
  });
}

// POST /pipeline/counties/:county - Process single county
const countyMatch = pathname.match(/^\/pipeline\/counties\/([a-z]+)$/i);
if (request.method === 'POST' && countyMatch) {
  const countyName = countyMatch[1];
  console.log(`[Worker] Starting county pipeline for ${countyName}`);

  const result = await processCounty(countyName, env.BUCKET, {
    OPENAI_API_KEY: env.OPENAI_API_KEY,
    PINECONE_API_KEY: env.PINECONE_API_KEY
  });

  return new Response(JSON.stringify(result, null, 2), {
    status: result.success ? 200 : 500,
    headers: { 'Content-Type': 'application/json' }
  });
}

// GET /pipeline/counties/status - Get county coverage status
if (request.method === 'GET' && pathname === '/pipeline/counties/status') {
  const enabled = getEnabledCounties();
  const skipped = getSkippedCounties();

  const status = {
    totalCounties: 10,
    enabledCount: enabled.length,
    skippedCount: skipped.length,
    enabled: enabled.map(c => ({
      name: c.name,
      fipsCode: c.fipsCode,
      platform: c.platform,
      categories: c.categories
    })),
    skipped: skipped.map(c => ({
      name: c.name,
      fipsCode: c.fipsCode,
      reason: c.skipReason
    }))
  };

  return new Response(JSON.stringify(status, null, 2), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
}

// POST /pipeline/counties/validate - Validate all county sources
if (request.method === 'POST' && pathname === '/pipeline/counties/validate') {
  console.log('[Worker] Validating county sources');

  const result = await validateCountySources();

  return new Response(JSON.stringify({
    validCount: result.valid.length,
    invalidCount: result.invalid.length,
    valid: result.valid,
    invalid: result.invalid
  }, null, 2), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
}
```

Update the health check endpoint to include county endpoints in the available routes list.
  </action>
  <verify>Worker builds successfully: `pnpm wrangler deploy --dry-run`</verify>
  <done>4 county HTTP endpoints added and worker builds</done>
</task>

<task type="auto">
  <name>Task 2: Update Convex jurisdictions table</name>
  <files>apps/convex/convex/schema.ts, apps/convex/convex/jurisdictions.ts</files>
  <action>
**FIRST:** Read apps/convex/convex/schema.ts to verify jurisdictions table exists and has required fields.

The existing schema has jurisdictions table with: name, type, stateCode, countyFips, isActive, createdAt, updatedAt.

**REQUIRED SCHEMA ADDITIONS:** Add these fields to the jurisdictions table in schema.ts:
- status: v.optional(v.union(v.literal('pending'), v.literal('active'), v.literal('error')))
- lastScrapedAt: v.optional(v.number())
- vectorCount: v.optional(v.number())
- error: v.optional(v.string())

Add index for FIPS lookup:
- .index('by_county_fips', ['countyFips'])

**THEN:** Create or update Convex functions to track county coverage status.

Add functions to:
1. List all Texas counties with coverage status
2. Update county processing status
3. Get county by FIPS code

```typescript
import { query, mutation } from './_generated/server';
import { v } from 'convex/values';

/**
 * Target Texas counties for MVP
 * Coverage status tracked per county
 * Note: Use countyFips field (schema field name) not fipsCode
 */
const TARGET_COUNTIES = [
  { name: 'Harris', countyFips: '48201' },
  { name: 'Dallas', countyFips: '48113' },
  { name: 'Tarrant', countyFips: '48439' },
  { name: 'Bexar', countyFips: '48029' },
  { name: 'Travis', countyFips: '48453' },
  { name: 'Collin', countyFips: '48085' },
  { name: 'Denton', countyFips: '48121' },
  { name: 'Fort Bend', countyFips: '48157' },
  { name: 'Williamson', countyFips: '48491' },
  { name: 'El Paso', countyFips: '48141' }
];

/**
 * List all Texas county jurisdictions with coverage status
 */
export const listTexasCounties = query({
  args: {},
  handler: async (ctx) => {
    // Get all county jurisdictions from database
    // Use stateCode (schema field) not state
    const countyJurisdictions = await ctx.db
      .query('jurisdictions')
      .filter(q =>
        q.and(
          q.eq(q.field('type'), 'county'),
          q.eq(q.field('stateCode'), 'TX')
        )
      )
      .collect();

    // Map to include coverage status
    return TARGET_COUNTIES.map(county => {
      const jurisdiction = countyJurisdictions.find(
        j => j.countyFips === county.countyFips
      );

      return {
        name: county.name,
        fipsCode: county.countyFips, // Return as fipsCode for API consistency
        jurisdictionId: `tx-county-${county.countyFips}`,
        covered: !!jurisdiction,
        lastScrapedAt: jurisdiction?.lastScrapedAt,
        vectorCount: jurisdiction?.vectorCount || 0,
        status: jurisdiction?.status || 'pending'
      };
    });
  }
});

/**
 * Update county jurisdiction status after pipeline processing
 */
export const updateCountyStatus = mutation({
  args: {
    fipsCode: v.string(), // Accept fipsCode from API, map to countyFips
    status: v.union(v.literal('active'), v.literal('error'), v.literal('pending')),
    lastScrapedAt: v.number(),
    vectorCount: v.optional(v.number()),
    error: v.optional(v.string())
  },
  handler: async (ctx, args) => {
    const { fipsCode, status, lastScrapedAt, vectorCount, error } = args;

    // Find existing jurisdiction record using countyFips field
    const existing = await ctx.db
      .query('jurisdictions')
      .withIndex('by_county_fips', q => q.eq('countyFips', fipsCode))
      .filter(q => q.eq(q.field('type'), 'county'))
      .first();

    const county = TARGET_COUNTIES.find(c => c.countyFips === fipsCode);
    const jurisdictionId = `tx-county-${fipsCode}`;

    if (existing) {
      // Update existing record
      await ctx.db.patch(existing._id, {
        status,
        lastScrapedAt,
        vectorCount: vectorCount || existing.vectorCount,
        error,
        updatedAt: Date.now()
      });
    } else {
      // Create new record using schema field names
      await ctx.db.insert('jurisdictions', {
        type: 'county',
        stateCode: 'TX', // Schema uses stateCode not state
        name: county?.name ? `${county.name} County` : `County ${fipsCode}`,
        countyFips: fipsCode, // Schema uses countyFips not fipsCode
        isActive: true,
        status,
        lastScrapedAt,
        vectorCount: vectorCount || 0,
        error,
        createdAt: Date.now(),
        updatedAt: Date.now()
      });
    }

    return { success: true, jurisdictionId };
  }
});

/**
 * Get county jurisdiction by FIPS code
 */
export const getCountyByFips = query({
  args: {
    fipsCode: v.string()
  },
  handler: async (ctx, args) => {
    // Use countyFips index for efficient lookup
    const jurisdiction = await ctx.db
      .query('jurisdictions')
      .withIndex('by_county_fips', q => q.eq('countyFips', args.fipsCode))
      .filter(q => q.eq(q.field('type'), 'county'))
      .first();

    const county = TARGET_COUNTIES.find(c => c.countyFips === args.fipsCode);

    return {
      name: county?.name || `County ${args.fipsCode}`,
      fipsCode: args.fipsCode,
      jurisdictionId: `tx-county-${args.fipsCode}`,
      covered: !!jurisdiction,
      ...jurisdiction
    };
  }
});

/**
 * Get coverage summary for Texas counties
 */
export const getTexasCountyCoverage = query({
  args: {},
  handler: async (ctx) => {
    // Use stateCode field (schema field name)
    const counties = await ctx.db
      .query('jurisdictions')
      .filter(q =>
        q.and(
          q.eq(q.field('type'), 'county'),
          q.eq(q.field('stateCode'), 'TX')
        )
      )
      .collect();

    const activeCount = counties.filter(c => c.status === 'active').length;
    const errorCount = counties.filter(c => c.status === 'error').length;
    const pendingCount = TARGET_COUNTIES.length - counties.length;
    const totalVectors = counties.reduce((sum, c) => sum + (c.vectorCount || 0), 0);

    return {
      targetCounties: TARGET_COUNTIES.length,
      coveredCounties: counties.length,
      activeCounties: activeCount,
      errorCounties: errorCount,
      pendingCounties: pendingCount,
      totalVectors,
      coveragePercent: Math.round((activeCount / TARGET_COUNTIES.length) * 100)
    };
  }
});
```
  </action>
  <verify>
1. Schema.ts has status field: `grep -q "status.*v.optional.*v.union.*pending.*active.*error" apps/convex/convex/schema.ts`
2. Schema.ts has by_county_fips index: `grep -q "by_county_fips" apps/convex/convex/schema.ts`
3. Convex functions compile: `pnpm -F @compliance-iq/convex exec convex dev --once`
  </verify>
  <done>Convex schema updated with status field and by_county_fips index; jurisdictions functions created for county coverage tracking</done>
</task>

<task type="auto">
  <name>Task 3: Generate coverage report</name>
  <files>apps/workers/src/counties/coverage.ts</files>
  <action>
Create coverage report generator that documents processed vs skipped counties.

```typescript
import { getEnabledCounties, getSkippedCounties } from './sources';
import type { CountyBatchPipelineResult, CountyPipelineResult } from './pipeline';

/**
 * County coverage report structure
 */
export interface CountyCoverageReport {
  generatedAt: string;
  summary: {
    targetCounties: number;
    enabledCounties: number;
    skippedCounties: number;
    processedCounties: number;
    failedCounties: number;
    totalOrdinances: number;
    totalVectors: number;
  };
  enabled: Array<{
    name: string;
    fipsCode: string;
    platform: string;
    categories: string[];
    status: 'processed' | 'failed' | 'pending';
    ordinancesCount?: number;
    vectorsCount?: number;
    error?: string;
  }>;
  skipped: Array<{
    name: string;
    fipsCode: string;
    reason: string;
  }>;
}

/**
 * Generate coverage report from pipeline results
 *
 * @param pipelineResult Result from processAllCounties
 * @returns Coverage report documenting all counties
 */
export function generateCoverageReport(
  pipelineResult?: CountyBatchPipelineResult
): CountyCoverageReport {
  const enabled = getEnabledCounties();
  const skipped = getSkippedCounties();

  // Map results by county name for lookup
  const resultsByCounty = new Map<string, CountyPipelineResult>();
  if (pipelineResult) {
    for (const result of pipelineResult.results) {
      resultsByCounty.set(result.county, result);
    }
  }

  const enabledWithStatus = enabled.map(county => {
    const result = resultsByCounty.get(county.name);

    return {
      name: county.name,
      fipsCode: county.fipsCode,
      platform: county.platform || 'unknown',
      categories: county.categories,
      status: result
        ? result.success
          ? 'processed' as const
          : 'failed' as const
        : 'pending' as const,
      ordinancesCount: result?.ordinancesProcessed,
      vectorsCount: result?.vectorsUpserted,
      error: result?.error
    };
  });

  const skippedWithReason = skipped.map(county => ({
    name: county.name,
    fipsCode: county.fipsCode,
    reason: county.skipReason || 'No online source available'
  }));

  const processedCount = enabledWithStatus.filter(c => c.status === 'processed').length;
  const failedCount = enabledWithStatus.filter(c => c.status === 'failed').length;

  return {
    generatedAt: new Date().toISOString(),
    summary: {
      targetCounties: 10,
      enabledCounties: enabled.length,
      skippedCounties: skipped.length,
      processedCounties: processedCount,
      failedCounties: failedCount,
      totalOrdinances: pipelineResult?.totalOrdinances || 0,
      totalVectors: pipelineResult?.totalVectors || 0
    },
    enabled: enabledWithStatus,
    skipped: skippedWithReason
  };
}

/**
 * Format coverage report as markdown for documentation
 */
export function formatCoverageReportMarkdown(report: CountyCoverageReport): string {
  const lines: string[] = [
    '# Texas County Coverage Report',
    '',
    `Generated: ${report.generatedAt}`,
    '',
    '## Summary',
    '',
    `| Metric | Count |`,
    `|--------|-------|`,
    `| Target Counties | ${report.summary.targetCounties} |`,
    `| Enabled Counties | ${report.summary.enabledCounties} |`,
    `| Skipped Counties | ${report.summary.skippedCounties} |`,
    `| Processed Counties | ${report.summary.processedCounties} |`,
    `| Failed Counties | ${report.summary.failedCounties} |`,
    `| Total Ordinances | ${report.summary.totalOrdinances} |`,
    `| Total Vectors | ${report.summary.totalVectors} |`,
    '',
    '## Enabled Counties',
    '',
    '| County | FIPS | Platform | Status | Ordinances | Vectors |',
    '|--------|------|----------|--------|------------|---------|'
  ];

  for (const county of report.enabled) {
    const ordinances = county.ordinancesCount ?? '-';
    const vectors = county.vectorsCount ?? '-';
    lines.push(
      `| ${county.name} | ${county.fipsCode} | ${county.platform} | ${county.status} | ${ordinances} | ${vectors} |`
    );
  }

  lines.push('', '## Skipped Counties', '');
  lines.push('| County | FIPS | Reason |');
  lines.push('|--------|------|--------|');

  for (const county of report.skipped) {
    lines.push(`| ${county.name} | ${county.fipsCode} | ${county.reason} |`);
  }

  return lines.join('\n');
}
```

Add export to counties/index.ts:
```typescript
export { generateCoverageReport, formatCoverageReportMarkdown } from './coverage';
```
  </action>
  <verify>TypeScript compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`</verify>
  <done>Coverage report generator created with markdown output</done>
</task>

<task type="auto">
  <name>Task 4: Test county jurisdiction query filtering</name>
  <files>scripts/test-county-query.ts</files>
  <action>
Create a test script that validates Pinecone queries filtered by county jurisdiction return relevant local regulations.

```typescript
/**
 * Test script for county jurisdiction query filtering
 * Validates Phase 4 Success Criterion #4:
 * "Test queries filtered by county return relevant local regulations"
 */
import { Pinecone } from '@pinecone-database/pinecone';
import OpenAI from 'openai';

async function testCountyQuery() {
  const pinecone = new Pinecone({
    apiKey: process.env.PINECONE_API_KEY!
  });

  const openai = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY!
  });

  const index = pinecone.index(process.env.PINECONE_INDEX || 'compliance-iq');

  // Test query: retail licensing regulations in Harris County
  const testQuery = 'retail business licensing requirements Harris County Texas';

  console.log(`[Test] Query: "${testQuery}"`);

  // Generate embedding for test query
  const embeddingResponse = await openai.embeddings.create({
    model: 'text-embedding-3-large',
    input: testQuery
  });
  const queryVector = embeddingResponse.data[0].embedding;

  // Query Pinecone with Harris County jurisdiction filter (TX-48201)
  const results = await index.query({
    vector: queryVector,
    topK: 10,
    includeMetadata: true,
    filter: {
      jurisdiction: { $eq: 'TX-48201' }
    }
  });

  console.log(`[Test] Results for jurisdiction TX-48201 (Harris County):`);
  console.log(`[Test] Found ${results.matches?.length || 0} matches`);

  if (!results.matches || results.matches.length === 0) {
    console.error('[Test] FAIL: No results returned for Harris County filter');
    process.exit(1);
  }

  // Validate all results have correct jurisdiction metadata
  let allValid = true;
  for (const match of results.matches) {
    const jurisdiction = match.metadata?.jurisdiction;
    const sourceType = match.metadata?.sourceType;

    console.log(`  - Score: ${match.score?.toFixed(4)} | Jurisdiction: ${jurisdiction} | Source: ${sourceType}`);

    if (jurisdiction !== 'TX-48201') {
      console.error(`[Test] FAIL: Result has wrong jurisdiction: ${jurisdiction}`);
      allValid = false;
    }

    if (sourceType !== 'county') {
      console.error(`[Test] WARN: Result has unexpected sourceType: ${sourceType}`);
    }
  }

  if (allValid) {
    console.log('[Test] PASS: All results have correct Harris County jurisdiction (TX-48201)');
  } else {
    console.error('[Test] FAIL: Some results have incorrect jurisdiction');
    process.exit(1);
  }

  // Test a second county to verify filtering works correctly
  console.log('\n[Test] Testing Dallas County filter (TX-48113)...');

  const dallasResults = await index.query({
    vector: queryVector,
    topK: 5,
    includeMetadata: true,
    filter: {
      jurisdiction: { $eq: 'TX-48113' }
    }
  });

  console.log(`[Test] Found ${dallasResults.matches?.length || 0} matches for Dallas County`);

  if (dallasResults.matches && dallasResults.matches.length > 0) {
    for (const match of dallasResults.matches) {
      if (match.metadata?.jurisdiction !== 'TX-48113') {
        console.error(`[Test] FAIL: Dallas query returned wrong jurisdiction`);
        process.exit(1);
      }
    }
    console.log('[Test] PASS: Dallas County filter returns correct jurisdiction');
  }

  console.log('\n[Test] County jurisdiction filtering validated successfully');
}

testCountyQuery().catch(err => {
  console.error('[Test] Error:', err);
  process.exit(1);
});
```

Run the test after county data is indexed.
  </action>
  <verify>Test passes when county data exists: `pnpm exec tsx scripts/test-county-query.ts` returns "PASS" messages</verify>
  <done>County jurisdiction query filtering validated - Pinecone queries with TX-48201 filter return only Harris County results</done>
</task>

</tasks>

<verification>
1. HTTP endpoints respond correctly for all 4 routes
2. Convex jurisdictions functions compile and deploy
3. Coverage report generates valid markdown
4. Worker builds: `pnpm wrangler deploy --dry-run`
5. Convex compiles: `pnpm -F @compliance-iq/convex exec convex dev --once` (if available)
</verification>

<success_criteria>
- POST /pipeline/counties triggers full batch processing
- POST /pipeline/counties/:county triggers single-county processing
- GET /pipeline/counties/status returns enabled/skipped breakdown
- Convex listTexasCounties returns all 10 counties with coverage status
- Coverage report markdown documents all counties
- Test script verifies Pinecone query with TX-48201 filter returns Harris County results
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-county-data/04-06-SUMMARY.md`
</output>
