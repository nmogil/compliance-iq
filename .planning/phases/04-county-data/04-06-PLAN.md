---
phase: 04-county-data
plan: 06
type: execute
wave: 4
depends_on: ["04-05"]
files_modified:
  - apps/workers/src/index.ts
  - apps/convex/convex/jurisdictions.ts
autonomous: true

must_haves:
  truths:
    - "HTTP endpoints available for triggering county pipeline"
    - "Convex jurisdictions table lists all 10 counties with coverage status"
    - "Coverage report documents processed vs skipped counties"
  artifacts:
    - path: "apps/workers/src/index.ts"
      provides: "County HTTP endpoints"
      contains: "/pipeline/counties"
    - path: "apps/convex/convex/jurisdictions.ts"
      provides: "Convex jurisdictions table operations for counties"
      contains: "tx-county"
  key_links:
    - from: "apps/workers/src/index.ts"
      to: "apps/workers/src/counties/index.ts"
      via: "County pipeline imports"
      pattern: "import.*from.*counties"
---

<objective>
Add HTTP endpoints for the county pipeline and update Convex jurisdictions table.

Purpose: Enable manual triggering of county pipeline and provide coverage tracking in the application database.

Output:
- HTTP endpoints for county pipeline (batch and single-county)
- Convex jurisdictions table with county coverage status
- Documentation of processed vs skipped counties
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-county-data/04-RESEARCH.md
@.planning/phases/04-county-data/04-05-SUMMARY.md
@apps/workers/src/index.ts
@apps/convex/convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add county HTTP endpoints</name>
  <files>apps/workers/src/index.ts</files>
  <action>
Add HTTP endpoints for county pipeline following the existing federal/texas patterns.

New endpoints to add:
1. `POST /pipeline/counties` - Process all enabled counties
2. `POST /pipeline/counties/:county` - Process single county (e.g., `/pipeline/counties/harris`)
3. `GET /pipeline/counties/status` - Get county source status (enabled/disabled)
4. `POST /pipeline/counties/validate` - Validate all county sources

Add to the existing worker router:

```typescript
import {
  processAllCounties,
  processCounty,
  getEnabledCounties,
  getSkippedCounties,
  validateCountySources
} from './counties';

// In the fetch handler, add routes:

// POST /pipeline/counties - Process all enabled counties
if (request.method === 'POST' && pathname === '/pipeline/counties') {
  console.log('[Worker] Starting county pipeline (all counties)');

  const result = await processAllCounties(env.BUCKET, {
    OPENAI_API_KEY: env.OPENAI_API_KEY,
    PINECONE_API_KEY: env.PINECONE_API_KEY,
    CONVEX_URL: env.CONVEX_URL
  });

  return new Response(JSON.stringify(result, null, 2), {
    status: result.success ? 200 : 207, // 207 Multi-Status if partial success
    headers: { 'Content-Type': 'application/json' }
  });
}

// POST /pipeline/counties/:county - Process single county
const countyMatch = pathname.match(/^\/pipeline\/counties\/([a-z]+)$/i);
if (request.method === 'POST' && countyMatch) {
  const countyName = countyMatch[1];
  console.log(`[Worker] Starting county pipeline for ${countyName}`);

  const result = await processCounty(countyName, env.BUCKET, {
    OPENAI_API_KEY: env.OPENAI_API_KEY,
    PINECONE_API_KEY: env.PINECONE_API_KEY
  });

  return new Response(JSON.stringify(result, null, 2), {
    status: result.success ? 200 : 500,
    headers: { 'Content-Type': 'application/json' }
  });
}

// GET /pipeline/counties/status - Get county coverage status
if (request.method === 'GET' && pathname === '/pipeline/counties/status') {
  const enabled = getEnabledCounties();
  const skipped = getSkippedCounties();

  const status = {
    totalCounties: 10,
    enabledCount: enabled.length,
    skippedCount: skipped.length,
    enabled: enabled.map(c => ({
      name: c.name,
      fipsCode: c.fipsCode,
      platform: c.platform,
      categories: c.categories
    })),
    skipped: skipped.map(c => ({
      name: c.name,
      fipsCode: c.fipsCode,
      reason: c.skipReason
    }))
  };

  return new Response(JSON.stringify(status, null, 2), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
}

// POST /pipeline/counties/validate - Validate all county sources
if (request.method === 'POST' && pathname === '/pipeline/counties/validate') {
  console.log('[Worker] Validating county sources');

  const result = await validateCountySources();

  return new Response(JSON.stringify({
    validCount: result.valid.length,
    invalidCount: result.invalid.length,
    valid: result.valid,
    invalid: result.invalid
  }, null, 2), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
}
```

Update the health check endpoint to include county endpoints in the available routes list.
  </action>
  <verify>Worker builds successfully: `pnpm wrangler deploy --dry-run`</verify>
  <done>4 county HTTP endpoints added and worker builds</done>
</task>

<task type="auto">
  <name>Task 2: Update Convex jurisdictions table</name>
  <files>apps/convex/convex/jurisdictions.ts</files>
  <action>
Create or update Convex functions to track county coverage status.

If jurisdictions.ts doesn't exist, create it. Add functions to:
1. List all Texas counties with coverage status
2. Update county processing status
3. Get county by FIPS code

```typescript
import { query, mutation } from './_generated/server';
import { v } from 'convex/values';

/**
 * Target Texas counties for MVP
 * Coverage status tracked per county
 */
const TARGET_COUNTIES = [
  { name: 'Harris', fipsCode: '48201' },
  { name: 'Dallas', fipsCode: '48113' },
  { name: 'Tarrant', fipsCode: '48439' },
  { name: 'Bexar', fipsCode: '48029' },
  { name: 'Travis', fipsCode: '48453' },
  { name: 'Collin', fipsCode: '48085' },
  { name: 'Denton', fipsCode: '48121' },
  { name: 'Fort Bend', fipsCode: '48157' },
  { name: 'Williamson', fipsCode: '48491' },
  { name: 'El Paso', fipsCode: '48141' }
];

/**
 * List all Texas county jurisdictions with coverage status
 */
export const listTexasCounties = query({
  args: {},
  handler: async (ctx) => {
    // Get all county jurisdictions from database
    const countyJurisdictions = await ctx.db
      .query('jurisdictions')
      .filter(q =>
        q.and(
          q.eq(q.field('type'), 'county'),
          q.eq(q.field('state'), 'TX')
        )
      )
      .collect();

    // Map to include coverage status
    return TARGET_COUNTIES.map(county => {
      const jurisdiction = countyJurisdictions.find(
        j => j.fipsCode === county.fipsCode
      );

      return {
        name: county.name,
        fipsCode: county.fipsCode,
        jurisdictionId: `tx-county-${county.fipsCode}`,
        covered: !!jurisdiction,
        lastScrapedAt: jurisdiction?.lastScrapedAt,
        vectorCount: jurisdiction?.vectorCount || 0,
        status: jurisdiction?.status || 'pending'
      };
    });
  }
});

/**
 * Update county jurisdiction status after pipeline processing
 */
export const updateCountyStatus = mutation({
  args: {
    fipsCode: v.string(),
    status: v.union(v.literal('active'), v.literal('error'), v.literal('pending')),
    lastScrapedAt: v.number(),
    vectorCount: v.optional(v.number()),
    error: v.optional(v.string())
  },
  handler: async (ctx, args) => {
    const { fipsCode, status, lastScrapedAt, vectorCount, error } = args;

    // Find existing jurisdiction record
    const existing = await ctx.db
      .query('jurisdictions')
      .filter(q =>
        q.and(
          q.eq(q.field('type'), 'county'),
          q.eq(q.field('fipsCode'), fipsCode)
        )
      )
      .first();

    const county = TARGET_COUNTIES.find(c => c.fipsCode === fipsCode);
    const jurisdictionId = `tx-county-${fipsCode}`;

    if (existing) {
      // Update existing record
      await ctx.db.patch(existing._id, {
        status,
        lastScrapedAt,
        vectorCount: vectorCount || existing.vectorCount,
        error,
        updatedAt: Date.now()
      });
    } else {
      // Create new record
      await ctx.db.insert('jurisdictions', {
        id: jurisdictionId,
        type: 'county',
        state: 'TX',
        name: county?.name || `County ${fipsCode}`,
        fipsCode,
        status,
        lastScrapedAt,
        vectorCount: vectorCount || 0,
        error,
        createdAt: Date.now(),
        updatedAt: Date.now()
      });
    }

    return { success: true, jurisdictionId };
  }
});

/**
 * Get county jurisdiction by FIPS code
 */
export const getCountyByFips = query({
  args: {
    fipsCode: v.string()
  },
  handler: async (ctx, args) => {
    const jurisdiction = await ctx.db
      .query('jurisdictions')
      .filter(q =>
        q.and(
          q.eq(q.field('type'), 'county'),
          q.eq(q.field('fipsCode'), args.fipsCode)
        )
      )
      .first();

    const county = TARGET_COUNTIES.find(c => c.fipsCode === args.fipsCode);

    return {
      name: county?.name || `County ${args.fipsCode}`,
      fipsCode: args.fipsCode,
      jurisdictionId: `tx-county-${args.fipsCode}`,
      covered: !!jurisdiction,
      ...jurisdiction
    };
  }
});

/**
 * Get coverage summary for Texas counties
 */
export const getTexasCountyCoverage = query({
  args: {},
  handler: async (ctx) => {
    const counties = await ctx.db
      .query('jurisdictions')
      .filter(q =>
        q.and(
          q.eq(q.field('type'), 'county'),
          q.eq(q.field('state'), 'TX')
        )
      )
      .collect();

    const activeCount = counties.filter(c => c.status === 'active').length;
    const errorCount = counties.filter(c => c.status === 'error').length;
    const pendingCount = TARGET_COUNTIES.length - counties.length;
    const totalVectors = counties.reduce((sum, c) => sum + (c.vectorCount || 0), 0);

    return {
      targetCounties: TARGET_COUNTIES.length,
      coveredCounties: counties.length,
      activeCounties: activeCount,
      errorCounties: errorCount,
      pendingCounties: pendingCount,
      totalVectors,
      coveragePercent: Math.round((activeCount / TARGET_COUNTIES.length) * 100)
    };
  }
});
```

Note: If the jurisdictions table doesn't exist in schema.ts, it may need to be added. Check existing schema first.
  </action>
  <verify>Convex functions compile: `pnpm -F @compliance-iq/convex exec convex dev --once`</verify>
  <done>Convex jurisdictions functions created for county coverage tracking</done>
</task>

<task type="auto">
  <name>Task 3: Generate coverage report</name>
  <files>apps/workers/src/counties/coverage.ts</files>
  <action>
Create coverage report generator that documents processed vs skipped counties.

```typescript
import { getEnabledCounties, getSkippedCounties } from './sources';
import type { CountyBatchPipelineResult, CountyPipelineResult } from './pipeline';

/**
 * County coverage report structure
 */
export interface CountyCoverageReport {
  generatedAt: string;
  summary: {
    targetCounties: number;
    enabledCounties: number;
    skippedCounties: number;
    processedCounties: number;
    failedCounties: number;
    totalOrdinances: number;
    totalVectors: number;
  };
  enabled: Array<{
    name: string;
    fipsCode: string;
    platform: string;
    categories: string[];
    status: 'processed' | 'failed' | 'pending';
    ordinancesCount?: number;
    vectorsCount?: number;
    error?: string;
  }>;
  skipped: Array<{
    name: string;
    fipsCode: string;
    reason: string;
  }>;
}

/**
 * Generate coverage report from pipeline results
 *
 * @param pipelineResult Result from processAllCounties
 * @returns Coverage report documenting all counties
 */
export function generateCoverageReport(
  pipelineResult?: CountyBatchPipelineResult
): CountyCoverageReport {
  const enabled = getEnabledCounties();
  const skipped = getSkippedCounties();

  // Map results by county name for lookup
  const resultsByCounty = new Map<string, CountyPipelineResult>();
  if (pipelineResult) {
    for (const result of pipelineResult.results) {
      resultsByCounty.set(result.county, result);
    }
  }

  const enabledWithStatus = enabled.map(county => {
    const result = resultsByCounty.get(county.name);

    return {
      name: county.name,
      fipsCode: county.fipsCode,
      platform: county.platform || 'unknown',
      categories: county.categories,
      status: result
        ? result.success
          ? 'processed' as const
          : 'failed' as const
        : 'pending' as const,
      ordinancesCount: result?.ordinancesProcessed,
      vectorsCount: result?.vectorsUpserted,
      error: result?.error
    };
  });

  const skippedWithReason = skipped.map(county => ({
    name: county.name,
    fipsCode: county.fipsCode,
    reason: county.skipReason || 'No online source available'
  }));

  const processedCount = enabledWithStatus.filter(c => c.status === 'processed').length;
  const failedCount = enabledWithStatus.filter(c => c.status === 'failed').length;

  return {
    generatedAt: new Date().toISOString(),
    summary: {
      targetCounties: 10,
      enabledCounties: enabled.length,
      skippedCounties: skipped.length,
      processedCounties: processedCount,
      failedCounties: failedCount,
      totalOrdinances: pipelineResult?.totalOrdinances || 0,
      totalVectors: pipelineResult?.totalVectors || 0
    },
    enabled: enabledWithStatus,
    skipped: skippedWithReason
  };
}

/**
 * Format coverage report as markdown for documentation
 */
export function formatCoverageReportMarkdown(report: CountyCoverageReport): string {
  const lines: string[] = [
    '# Texas County Coverage Report',
    '',
    `Generated: ${report.generatedAt}`,
    '',
    '## Summary',
    '',
    `| Metric | Count |`,
    `|--------|-------|`,
    `| Target Counties | ${report.summary.targetCounties} |`,
    `| Enabled Counties | ${report.summary.enabledCounties} |`,
    `| Skipped Counties | ${report.summary.skippedCounties} |`,
    `| Processed Counties | ${report.summary.processedCounties} |`,
    `| Failed Counties | ${report.summary.failedCounties} |`,
    `| Total Ordinances | ${report.summary.totalOrdinances} |`,
    `| Total Vectors | ${report.summary.totalVectors} |`,
    '',
    '## Enabled Counties',
    '',
    '| County | FIPS | Platform | Status | Ordinances | Vectors |',
    '|--------|------|----------|--------|------------|---------|'
  ];

  for (const county of report.enabled) {
    const ordinances = county.ordinancesCount ?? '-';
    const vectors = county.vectorsCount ?? '-';
    lines.push(
      `| ${county.name} | ${county.fipsCode} | ${county.platform} | ${county.status} | ${ordinances} | ${vectors} |`
    );
  }

  lines.push('', '## Skipped Counties', '');
  lines.push('| County | FIPS | Reason |');
  lines.push('|--------|------|--------|');

  for (const county of report.skipped) {
    lines.push(`| ${county.name} | ${county.fipsCode} | ${county.reason} |`);
  }

  return lines.join('\n');
}
```

Add export to counties/index.ts:
```typescript
export { generateCoverageReport, formatCoverageReportMarkdown } from './coverage';
```
  </action>
  <verify>TypeScript compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`</verify>
  <done>Coverage report generator created with markdown output</done>
</task>

</tasks>

<verification>
1. HTTP endpoints respond correctly for all 4 routes
2. Convex jurisdictions functions compile and deploy
3. Coverage report generates valid markdown
4. Worker builds: `pnpm wrangler deploy --dry-run`
5. Convex compiles: `pnpm -F @compliance-iq/convex exec convex dev --once` (if available)
</verification>

<success_criteria>
- POST /pipeline/counties triggers full batch processing
- POST /pipeline/counties/:county triggers single-county processing
- GET /pipeline/counties/status returns enabled/skipped breakdown
- Convex listTexasCounties returns all 10 counties with coverage status
- Coverage report markdown documents all counties
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-county-data/04-06-SUMMARY.md`
</output>
