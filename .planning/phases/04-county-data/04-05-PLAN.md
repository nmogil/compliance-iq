---
phase: 04-county-data
plan: 05
type: execute
wave: 4
depends_on: ["04-04"]
files_modified:
  - apps/workers/src/counties/pipeline.ts
  - apps/workers/src/counties/index.ts
autonomous: true

must_haves:
  truths:
    - "County pipeline processes all enabled counties end-to-end"
    - "Checkpoint-based resumption works for failed runs"
    - "County vectors indexed in Pinecone with correct jurisdiction metadata"
  artifacts:
    - path: "apps/workers/src/counties/pipeline.ts"
      provides: "End-to-end county pipeline orchestrator"
      exports: ["processCounty", "processAllCounties", "CountyPipelineResult", "CountyBatchPipelineResult"]
    - path: "apps/workers/src/counties/index.ts"
      provides: "Module exports for counties package"
      exports: ["processCounty", "processAllCounties", "TARGET_COUNTIES", "getEnabledCounties"]
  key_links:
    - from: "apps/workers/src/counties/pipeline.ts"
      to: "apps/workers/src/pinecone.ts"
      via: "Vector indexing"
      pattern: "import.*from.*pinecone"
    - from: "apps/workers/src/counties/pipeline.ts"
      to: "apps/workers/src/federal/embed.ts"
      via: "Embedding generation"
      pattern: "import.*embedChunks.*from.*federal/embed"
---

<objective>
Create the county pipeline orchestrator for end-to-end processing.

Purpose: Orchestrate the complete county data pipeline from fetch through Pinecone indexing, with checkpoint-based resumption for resilience.

Output:
- Pipeline orchestrator mirroring texas/pipeline.ts patterns
- Checkpoint management for resume on failure
- Pinecone indexing with county jurisdiction metadata
- Module exports for the counties package
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-county-data/04-RESEARCH.md
@.planning/phases/04-county-data/04-04-SUMMARY.md
@apps/workers/src/texas/pipeline.ts
@apps/workers/src/pinecone.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create county pipeline orchestrator</name>
  <files>apps/workers/src/counties/pipeline.ts</files>
  <action>
Create pipeline orchestrator following texas/pipeline.ts patterns.

Pipeline flow:
1. Load checkpoint (if exists) for resumption
2. For each enabled county:
   a. Fetch ordinances via adapter
   b. Store raw HTML in R2
   c. Chunk ordinances
   d. Generate embeddings (reuse embedChunks from federal)
   e. Prepare Pinecone records with metadata
   f. Upsert vectors to Pinecone
   g. Save checkpoint
3. Clear checkpoint on completion
4. Sync to Convex (best-effort)

```typescript
import { embedChunks } from '../federal/embed';
import { initPinecone, getIndex, upsertChunks } from '../pinecone';
import { fetchCountyOrdinances } from './fetch';
import { chunkCountyOrdinance } from './chunk';
import {
  saveCountyCheckpoint,
  loadCountyCheckpoint,
  clearCountyCheckpoint
} from './storage';
import { getEnabledCounties, getCountyByName } from './sources';
import type {
  CountyOrdinance,
  CountyChunk,
  CountyCheckpoint,
  CountySourceConfig
} from './types';
import type { ChunkMetadata } from '../pinecone';

/**
 * Result of processing a single county
 */
export interface CountyPipelineResult {
  county: string;
  fipsCode: string;
  success: boolean;
  ordinancesProcessed: number;
  chunksGenerated: number;
  vectorsUpserted: number;
  durationMs: number;
  error?: string;
}

/**
 * Result of batch county processing
 */
export interface CountyBatchPipelineResult {
  success: boolean;
  countiesProcessed: number;
  countiesSkipped: number;
  totalOrdinances: number;
  totalChunks: number;
  totalVectors: number;
  durationMs: number;
  results: CountyPipelineResult[];
  errors: string[];
}

/**
 * Process a single county: fetch -> store -> chunk -> embed -> index
 */
export async function processCounty(
  countyName: string,
  bucket: R2Bucket,
  env: {
    OPENAI_API_KEY: string;
    PINECONE_API_KEY: string;
  }
): Promise<CountyPipelineResult> {
  const startTime = Date.now();
  const config = getCountyByName(countyName);

  if (!config) {
    return {
      county: countyName,
      fipsCode: '',
      success: false,
      ordinancesProcessed: 0,
      chunksGenerated: 0,
      vectorsUpserted: 0,
      durationMs: Date.now() - startTime,
      error: `County not found: ${countyName}`
    };
  }

  if (!config.enabled) {
    return {
      county: countyName,
      fipsCode: config.fipsCode,
      success: false,
      ordinancesProcessed: 0,
      chunksGenerated: 0,
      vectorsUpserted: 0,
      durationMs: Date.now() - startTime,
      error: `County disabled: ${config.skipReason}`
    };
  }

  console.log(`[CountyPipeline] Processing ${countyName} County`);

  try {
    // 1. Fetch ordinances
    const { result: fetchResult, ordinances } = await fetchCountyOrdinances(
      countyName,
      bucket
    );

    if (!fetchResult.success) {
      return {
        county: countyName,
        fipsCode: config.fipsCode,
        success: false,
        ordinancesProcessed: 0,
        chunksGenerated: 0,
        vectorsUpserted: 0,
        durationMs: Date.now() - startTime,
        error: fetchResult.error
      };
    }

    // 2. Chunk ordinances
    const context = {
      county: config.name,
      fipsCode: config.fipsCode,
      codeName: 'County Code',
      categories: config.categories
    };

    const chunks: CountyChunk[] = [];
    for (const ordinance of ordinances) {
      const sectionChunks = chunkCountyOrdinance(ordinance, context);
      chunks.push(...sectionChunks);
    }

    console.log(`[CountyPipeline] ${countyName}: ${chunks.length} chunks from ${ordinances.length} ordinances`);

    if (chunks.length === 0) {
      return {
        county: countyName,
        fipsCode: config.fipsCode,
        success: true,
        ordinancesProcessed: ordinances.length,
        chunksGenerated: 0,
        vectorsUpserted: 0,
        durationMs: Date.now() - startTime
      };
    }

    // 3. Generate embeddings
    // Use type assertion since CountyChunk has same embedding interface as CFRChunk
    const chunksWithEmbeddings = await embedChunks(
      chunks as unknown as Array<{ chunkId: string; text: string }>,
      env.OPENAI_API_KEY
    );

    // 4. Prepare Pinecone records
    const records = chunksWithEmbeddings.map((chunk, i) => ({
      id: chunks[i].chunkId,
      values: chunk.embedding,
      metadata: {
        chunkId: chunks[i].chunkId,
        sourceId: chunks[i].sourceId,
        sourceType: 'county' as const,
        jurisdiction: `TX-${chunks[i].fipsCode}`, // e.g., "TX-48201"
        text: chunks[i].text,
        citation: chunks[i].citation,
        url: chunks[i].url,
        category: chunks[i].category || config.categories[0],
        chunkIndex: chunks[i].chunkIndex,
        totalChunks: chunks[i].totalChunks,
        indexedAt: new Date().toISOString()
      } satisfies ChunkMetadata
    }));

    // 5. Upsert to Pinecone
    const index = await getIndex(env.PINECONE_API_KEY);
    await upsertChunks(index, records);

    console.log(`[CountyPipeline] ${countyName}: ${records.length} vectors upserted`);

    return {
      county: countyName,
      fipsCode: config.fipsCode,
      success: true,
      ordinancesProcessed: ordinances.length,
      chunksGenerated: chunks.length,
      vectorsUpserted: records.length,
      durationMs: Date.now() - startTime
    };
  } catch (error) {
    console.error(`[CountyPipeline] Error processing ${countyName}:`, error);

    return {
      county: countyName,
      fipsCode: config.fipsCode,
      success: false,
      ordinancesProcessed: 0,
      chunksGenerated: 0,
      vectorsUpserted: 0,
      durationMs: Date.now() - startTime,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Process all enabled counties with checkpoint resumption
 */
export async function processAllCounties(
  bucket: R2Bucket,
  env: {
    OPENAI_API_KEY: string;
    PINECONE_API_KEY: string;
    CONVEX_URL?: string;
  }
): Promise<CountyBatchPipelineResult> {
  const startTime = Date.now();
  const results: CountyPipelineResult[] = [];
  const errors: string[] = [];

  // Load checkpoint
  let checkpoint = await loadCountyCheckpoint(bucket);
  const counties = getEnabledCounties();

  console.log(`[CountyPipeline] Starting batch processing for ${counties.length} counties`);

  // Find starting point if resuming
  let startIndex = 0;
  if (checkpoint?.lastProcessedCounty) {
    const lastIndex = counties.findIndex(c => c.name === checkpoint.lastProcessedCounty);
    if (lastIndex >= 0) {
      startIndex = lastIndex + 1;
      console.log(`[CountyPipeline] Resuming from county ${startIndex + 1}/${counties.length}`);
    }
  }

  let totalOrdinances = checkpoint?.chunksProcessed || 0;
  let totalChunks = 0;
  let totalVectors = 0;

  for (let i = startIndex; i < counties.length; i++) {
    const county = counties[i];
    console.log(`[CountyPipeline] Processing county ${i + 1}/${counties.length}: ${county.name}`);

    const result = await processCounty(county.name, bucket, env);
    results.push(result);

    if (result.success) {
      totalOrdinances += result.ordinancesProcessed;
      totalChunks += result.chunksGenerated;
      totalVectors += result.vectorsUpserted;
    } else {
      errors.push(`${county.name}: ${result.error}`);
    }

    // Save checkpoint after each county
    const newCheckpoint: CountyCheckpoint = {
      sourceType: 'county',
      lastProcessedCounty: county.name,
      timestamp: new Date().toISOString(),
      chunksProcessed: totalChunks,
      status: 'in_progress'
    };
    await saveCountyCheckpoint(bucket, newCheckpoint);
  }

  // Clear checkpoint on completion
  await clearCountyCheckpoint(bucket);

  const countiesProcessed = results.filter(r => r.success).length;
  const countiesSkipped = results.filter(r => !r.success).length;

  console.log(
    `[CountyPipeline] Batch complete: ${countiesProcessed} processed, ${countiesSkipped} skipped, ${totalVectors} vectors`
  );

  // Best-effort Convex sync
  if (env.CONVEX_URL) {
    try {
      await syncConvexCountySources(env.CONVEX_URL, {
        countiesProcessed,
        totalVectors,
        durationMs: Date.now() - startTime
      });
    } catch (error) {
      console.error('[CountyPipeline] Convex sync failed:', error);
    }
  }

  return {
    success: errors.length === 0,
    countiesProcessed,
    countiesSkipped,
    totalOrdinances,
    totalChunks,
    totalVectors,
    durationMs: Date.now() - startTime,
    results,
    errors
  };
}

/**
 * Sync county processing status to Convex (best-effort)
 */
async function syncConvexCountySources(
  convexUrl: string,
  stats: {
    countiesProcessed: number;
    totalVectors: number;
    durationMs: number;
  }
): Promise<void> {
  // Convex mutation to update county sources status
  // Implementation depends on Convex function structure
  console.log('[CountyPipeline] Convex sync:', stats);

  // TODO: Implement actual Convex sync when sources:updateCountyStatus exists
  // const response = await fetch(`${convexUrl}/api/mutation`, {
  //   method: 'POST',
  //   headers: { 'Content-Type': 'application/json' },
  //   body: JSON.stringify({
  //     path: 'sources:updateCountyStatus',
  //     args: {
  //       status: 'complete',
  //       lastScrapedAt: Date.now(),
  //       ...stats
  //     }
  //   })
  // });
}
```
  </action>
  <verify>TypeScript compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`</verify>
  <done>processCounty and processAllCounties implement full pipeline with checkpoint resumption</done>
</task>

<task type="auto">
  <name>Task 2: Create module exports</name>
  <files>apps/workers/src/counties/index.ts</files>
  <action>
Create module index that exports all county package functionality.

```typescript
/**
 * Texas Counties Data Pipeline
 *
 * Provides scraping, storage, chunking, and pipeline orchestration
 * for top 10 Texas county ordinances.
 *
 * Target counties:
 * - Harris (48201) - Houston area
 * - Dallas (48113) - Dallas area
 * - Tarrant (48439) - Fort Worth area
 * - Bexar (48029) - San Antonio area
 * - Travis (48453) - Austin area
 * - Collin (48085) - Plano/McKinney area
 * - Denton (48121) - Denton area
 * - Fort Bend (48157) - Sugar Land area
 * - Williamson (48491) - Round Rock area
 * - El Paso (48141) - El Paso area
 */

// Types
export type {
  CountyOrdinance,
  CourtOrder,
  CountySourceConfig,
  CountyChunk,
  CountyCheckpoint,
  CountyAdapter
} from './types';

// Sources registry
export {
  TARGET_COUNTIES,
  getEnabledCounties,
  getSkippedCounties,
  getCountyByName,
  getCountyByFips
} from './sources';

// Adapters
export {
  CountyAdapterBase,
  MunicodeAdapter,
  ElawsAdapter,
  AmlegalAdapter,
  getAdapterForCounty,
  getAdaptersForEnabledCounties
} from './adapters';

// Storage
export {
  storeCountyOrdinance,
  getCountyOrdinance,
  listCountyOrdinances,
  saveCountyCheckpoint,
  loadCountyCheckpoint,
  clearCountyCheckpoint
} from './storage';

// Chunking
export {
  chunkCountyOrdinance,
  chunkCounty,
  getCountyChunkStats
} from './chunk';

// Fetch orchestrator
export {
  fetchCountyOrdinances,
  fetchAllEnabledCounties,
  validateCountySources
} from './fetch';

// Pipeline
export {
  processCounty,
  processAllCounties,
  CountyPipelineResult,
  CountyBatchPipelineResult
} from './pipeline';
```
  </action>
  <verify>All exports available: `pnpm -F @compliance-iq/workers exec tsc --noEmit`</verify>
  <done>All county package exports available from counties/index.ts</done>
</task>

</tasks>

<verification>
1. Pipeline processes fetch -> store -> chunk -> embed -> index flow
2. Checkpoint saves after each county for resumption
3. Pinecone metadata includes jurisdiction as "TX-{fipsCode}"
4. Module exports all county package functionality
5. All code compiles: `pnpm -F @compliance-iq/workers exec tsc --noEmit`
</verification>

<success_criteria>
- processCounty handles single county end-to-end
- processAllCounties handles batch with checkpoint resumption
- Pinecone vectors have sourceType: "county" and jurisdiction: "TX-48XXX"
- Best-effort Convex sync implemented
- All exports available from counties/index.ts
- No TypeScript compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-county-data/04-05-SUMMARY.md`
</output>
