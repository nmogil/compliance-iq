---
phase: 03-state-data
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/workers/src/lib/scraper.ts
autonomous: true

must_haves:
  truths:
    - "Retry logic with exponential backoff handles transient failures"
    - "Rate limiting delays prevent 429 errors from government websites"
    - "Retry-After headers are parsed and respected"
  artifacts:
    - path: "apps/workers/src/lib/scraper.ts"
      provides: "retryWithBackoff, delay, fetchWithRateLimit utilities"
      exports: ["retryWithBackoff", "delay", "fetchWithRateLimit", "NotFoundError"]
      min_lines: 80
  key_links:
    - from: "apps/workers/src/lib/scraper.ts"
      to: "capitol.texas.gov"
      via: "fetch requests"
      pattern: "fetch.*capitol\\.texas\\.gov"
---

<objective>
Create shared scraper utilities for rate-limited HTTP requests with exponential backoff.

Purpose: Texas government websites (capitol.texas.gov, sos.state.tx.us) require careful rate limiting to avoid 429 errors. This plan creates reusable utilities that both the statutes and TAC scrapers will use.

Output:
- Shared scraper.ts with retry logic, rate limiting, and error handling
- Exponential backoff with Retry-After header support
- Custom error types for scraping operations
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-state-data/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scraper utilities with retry and rate limiting</name>
  <files>apps/workers/src/lib/scraper.ts</files>
  <action>
Create a new file apps/workers/src/lib/scraper.ts with the following:

1. **Custom Error Types:**
```typescript
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'NotFoundError';
  }
}

export class RateLimitError extends Error {
  retryAfter?: number; // seconds
  constructor(message: string, retryAfter?: number) {
    super(message);
    this.name = 'RateLimitError';
    this.retryAfter = retryAfter;
  }
}

export class ScrapingError extends Error {
  statusCode?: number;
  constructor(message: string, statusCode?: number) {
    super(message);
    this.name = 'ScrapingError';
    this.statusCode = statusCode;
  }
}
```

2. **Retry Configuration:**
```typescript
export interface RetryConfig {
  maxRetries: number;     // Default: 3
  baseDelay: number;      // Default: 1000 (1 second)
  maxDelay: number;       // Default: 8000 (8 seconds)
  jitter: boolean;        // Default: true (add randomness to prevent thundering herd)
}

const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxRetries: 3,
  baseDelay: 1000,
  maxDelay: 8000,
  jitter: true,
};
```

3. **delay() utility:**
```typescript
export function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}
```

4. **calculateDelay() with exponential backoff and jitter:**
```typescript
function calculateDelay(attempt: number, config: RetryConfig): number {
  // Exponential: 1s, 2s, 4s, 8s...
  let delayMs = config.baseDelay * Math.pow(2, attempt);

  // Cap at maxDelay
  delayMs = Math.min(delayMs, config.maxDelay);

  // Add jitter (0-25% of delay) to prevent thundering herd
  if (config.jitter) {
    const jitterMs = Math.random() * delayMs * 0.25;
    delayMs += jitterMs;
  }

  return Math.floor(delayMs);
}
```

5. **extractRetryAfter() to parse Retry-After header:**
```typescript
function extractRetryAfter(response: Response): number | null {
  const retryAfter = response.headers.get('Retry-After');
  if (!retryAfter) return null;

  // Try parsing as seconds
  const seconds = parseInt(retryAfter, 10);
  if (!isNaN(seconds)) {
    return seconds * 1000; // Convert to ms
  }

  // Try parsing as HTTP date
  const date = new Date(retryAfter);
  if (!isNaN(date.getTime())) {
    const delayMs = date.getTime() - Date.now();
    return Math.max(0, delayMs);
  }

  return null;
}
```

6. **retryWithBackoff() - Main retry wrapper:**
```typescript
export async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  operationName: string,
  config: Partial<RetryConfig> = {}
): Promise<T> {
  const fullConfig = { ...DEFAULT_RETRY_CONFIG, ...config };
  let lastError: Error | null = null;

  for (let attempt = 0; attempt <= fullConfig.maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));

      // Don't retry on 404 (resource doesn't exist)
      if (error instanceof NotFoundError) {
        throw error;
      }

      // Check if we've exhausted retries
      if (attempt >= fullConfig.maxRetries) {
        console.error(`[Scraper] ${operationName} failed after ${attempt + 1} attempts: ${lastError.message}`);
        throw lastError;
      }

      // Calculate delay (use Retry-After if available)
      let delayMs: number;
      if (error instanceof RateLimitError && error.retryAfter) {
        delayMs = error.retryAfter * 1000;
        console.log(`[Scraper] Rate limited, using Retry-After: ${delayMs}ms`);
      } else {
        delayMs = calculateDelay(attempt, fullConfig);
      }

      console.log(`[Scraper] ${operationName} failed (attempt ${attempt + 1}/${fullConfig.maxRetries + 1}), retrying in ${delayMs}ms`);
      await delay(delayMs);
    }
  }

  throw lastError ?? new Error('Retry failed with unknown error');
}
```

7. **fetchWithRateLimit() - Fetch wrapper with rate limiting:**
```typescript
export interface FetchOptions {
  rateLimitDelayMs?: number; // Delay between requests (default: 200ms)
  headers?: Record<string, string>;
  retryConfig?: Partial<RetryConfig>;
}

// Track last request time per domain
const lastRequestTime: Record<string, number> = {};

export async function fetchWithRateLimit(
  url: string,
  operationName: string,
  options: FetchOptions = {}
): Promise<Response> {
  const { rateLimitDelayMs = 200, headers = {}, retryConfig = {} } = options;

  // Extract domain for rate limiting
  const domain = new URL(url).hostname;

  // Enforce minimum delay between requests to same domain
  const now = Date.now();
  const lastTime = lastRequestTime[domain] || 0;
  const elapsed = now - lastTime;

  if (elapsed < rateLimitDelayMs) {
    await delay(rateLimitDelayMs - elapsed);
  }

  // Update last request time
  lastRequestTime[domain] = Date.now();

  // Make request with retry
  return retryWithBackoff(
    async () => {
      const response = await fetch(url, {
        headers: {
          'User-Agent': 'ComplianceIQ-Bot/1.0 (Legal research tool; +https://compliance-iq.com)',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          ...headers,
        },
      });

      // Handle specific status codes
      if (response.status === 404) {
        throw new NotFoundError(`Resource not found: ${url}`);
      }

      if (response.status === 429) {
        const retryAfterMs = extractRetryAfter(response);
        throw new RateLimitError(
          `Rate limited: ${url}`,
          retryAfterMs ? retryAfterMs / 1000 : undefined
        );
      }

      if (!response.ok) {
        throw new ScrapingError(
          `HTTP ${response.status}: ${response.statusText} for ${url}`,
          response.status
        );
      }

      return response;
    },
    operationName,
    retryConfig
  );
}
```

8. **Export all types and functions:**
```typescript
export {
  NotFoundError,
  RateLimitError,
  ScrapingError,
  RetryConfig,
  FetchOptions,
  delay,
  retryWithBackoff,
  fetchWithRateLimit,
};
```

Add comprehensive JSDoc comments explaining each function, including examples.
  </action>
  <verify>
```bash
cd /Users/noahmogil/Projects/compliance-iq && pnpm -F @compliance-iq/workers exec tsc --noEmit apps/workers/src/lib/scraper.ts
```
TypeScript compiles without errors.
  </verify>
  <done>
Scraper utilities file created with:
- Custom error types (NotFoundError, RateLimitError, ScrapingError)
- Exponential backoff with jitter
- Retry-After header parsing
- Per-domain rate limiting
- All functions exported with JSDoc documentation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for scraper utilities</name>
  <files>apps/workers/src/lib/scraper.test.ts</files>
  <action>
Create a test file for the scraper utilities to verify core behaviors:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import {
  delay,
  retryWithBackoff,
  NotFoundError,
  RateLimitError
} from './scraper';

describe('scraper utilities', () => {
  describe('delay', () => {
    it('should wait for specified milliseconds', async () => {
      const start = Date.now();
      await delay(100);
      const elapsed = Date.now() - start;
      expect(elapsed).toBeGreaterThanOrEqual(95); // Allow small variance
      expect(elapsed).toBeLessThan(200);
    });
  });

  describe('retryWithBackoff', () => {
    it('should return immediately on success', async () => {
      const fn = vi.fn().mockResolvedValue('success');
      const result = await retryWithBackoff(fn, 'test');
      expect(result).toBe('success');
      expect(fn).toHaveBeenCalledTimes(1);
    });

    it('should retry on transient failures', async () => {
      const fn = vi.fn()
        .mockRejectedValueOnce(new Error('Transient error'))
        .mockRejectedValueOnce(new Error('Transient error'))
        .mockResolvedValue('success');

      const result = await retryWithBackoff(fn, 'test', {
        baseDelay: 10, // Fast for testing
        jitter: false
      });

      expect(result).toBe('success');
      expect(fn).toHaveBeenCalledTimes(3);
    });

    it('should not retry on NotFoundError', async () => {
      const fn = vi.fn().mockRejectedValue(new NotFoundError('Not found'));

      await expect(retryWithBackoff(fn, 'test')).rejects.toThrow(NotFoundError);
      expect(fn).toHaveBeenCalledTimes(1);
    });

    it('should throw after max retries exceeded', async () => {
      const fn = vi.fn().mockRejectedValue(new Error('Always fails'));

      await expect(retryWithBackoff(fn, 'test', {
        maxRetries: 2,
        baseDelay: 10,
        jitter: false
      })).rejects.toThrow('Always fails');

      expect(fn).toHaveBeenCalledTimes(3); // Initial + 2 retries
    });

    it('should use Retry-After from RateLimitError', async () => {
      const start = Date.now();
      const fn = vi.fn()
        .mockRejectedValueOnce(new RateLimitError('Rate limited', 0.1)) // 0.1 seconds
        .mockResolvedValue('success');

      await retryWithBackoff(fn, 'test');

      const elapsed = Date.now() - start;
      expect(elapsed).toBeGreaterThanOrEqual(95); // ~100ms from Retry-After
    });
  });
});
```

Ensure tests cover:
- Basic delay functionality
- Successful first attempt returns immediately
- Transient failures trigger retry
- NotFoundError is not retried
- Max retries exceeded throws error
- RateLimitError uses Retry-After value
  </action>
  <verify>
```bash
cd /Users/noahmogil/Projects/compliance-iq && pnpm -F @compliance-iq/workers test scraper
```
All tests pass.
  </verify>
  <done>
Unit tests for scraper utilities pass. Core retry logic verified.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Run TypeScript check:
```bash
cd /Users/noahmogil/Projects/compliance-iq && pnpm -F @compliance-iq/workers exec tsc --noEmit
```

2. Run scraper tests:
```bash
cd /Users/noahmogil/Projects/compliance-iq && pnpm -F @compliance-iq/workers test scraper
```

3. Verify file exists:
```bash
ls -la /Users/noahmogil/Projects/compliance-iq/apps/workers/src/lib/scraper.ts
```
</verification>

<success_criteria>
- apps/workers/src/lib/scraper.ts exists with all utilities
- Exports: retryWithBackoff, delay, fetchWithRateLimit, NotFoundError, RateLimitError, ScrapingError
- Unit tests pass for core retry logic
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-state-data/03-02-SUMMARY.md`
</output>
